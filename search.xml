<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java多线程与并发.md</title>
      <link href="/2023/08/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91-md/"/>
      <url>/2023/08/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91-md/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 多线程与并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式搜索引擎Elasticsearch</title>
      <link href="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/"/>
      <url>/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/elasticsearchbg.jpg"></p><h1 id="分布式搜索引擎Elasticsearch"><a href="#分布式搜索引擎Elasticsearch" class="headerlink" title="分布式搜索引擎Elasticsearch"></a>分布式搜索引擎Elasticsearch</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><blockquote><p>简单记录学习的elasticsearch知识点</p></blockquote><h2 id="2-初识elasticsearch"><a href="#2-初识elasticsearch" class="headerlink" title="2.初识elasticsearch"></a>2.初识elasticsearch</h2><h3 id="2-1-了解elasticsearch"><a href="#2-1-了解elasticsearch" class="headerlink" title="2.1.了解elasticsearch"></a>2.1.了解elasticsearch</h3><h4 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1.简介"></a>2.1.1.简介</h4><blockquote><p><strong>Elasticsearch</strong> 是位于 Elastic Stack 核心的分布式搜索和分析引擎。Logstash 和 Beats 有助于收集、聚合和丰富您的数据并将其存储在 <strong>Elasticsearch</strong> 中。Kibana 使您能够以交互方式探索、可视化和分享对数据的见解，并管理和监控堆栈。<strong>Elasticsearch</strong> 是索引、搜索和分析魔法发生的地方。</p><p><strong>Elasticsearch</strong> 为所有类型的数据提供近乎实时的搜索和分析。无论您拥有结构化或非结构化文本、数字数据还是地理空间数据，<strong>Elasticsearch</strong> 都能以支持快速搜索的方式高效地存储和索引它。您可以超越简单的数据检索和聚合信息来发现数据中的趋势和模式。随着您的数据和查询量的增长，<strong>Elasticsearch</strong> 的分布式特性使您的部署能够随之无缝增长。(<a href="https://baike.baidu.com/item/elasticsearch/3411206">elasticsearch_百度百科 (baidu.com)</a>)</p><p>源码:<a href="https://github.com/elastic/elasticsearch">elastic/elasticsearch: Free and Open, Distributed, RESTful Search Engine (github.com)</a></p></blockquote><h4 id="2-1-2-ELK"><a href="#2-1-2-ELK" class="headerlink" title="2.1.2.ELK"></a>2.1.2.ELK</h4><blockquote><p><strong>ELK</strong>是三个开源软件的缩写，分别表示：<strong>Elasticsearch, Logstash, Kibana</strong> , 它们都是开源软件。 新增了一个FileBeat，它是一个轻量级的日志收集处理工具 (Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash。</p><p>而<strong>Elasticsearch</strong>是elastic stack的核心，负责存储、搜索、分析数据。</p></blockquote><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/ELK.png" style="zoom:80%;"><h3 id="2-2-倒排索引"><a href="#2-2-倒排索引" class="headerlink" title="2.2.倒排索引"></a>2.2.倒排索引</h3><h4 id="2-2-1-正排索引"><a href="#2-2-1-正排索引" class="headerlink" title="2.2.1.正排索引"></a>2.2.1.正排索引</h4><blockquote><p>正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/forward_index_example.png"></p><blockquote><p>给下表（tb_goods）中的id创建索引：</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/tb_goods.png"></p><blockquote><p>如果是根据id查询，那么直接走索引，查询速度非常快。<br>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p><ol><li>用户搜索数据，条件是title符合<code>"%手机%"</code></li><li>逐行获取数据，比如id为1的数据</li><li>判断数据中的title是否符合用户搜索条件</li><li>如果符合则放入结果集，不符合则丢弃。回到步骤1</li></ol><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。</p></blockquote><h4 id="2-2-2-倒排索引"><a href="#2-2-2-倒排索引" class="headerlink" title="2.2.2.倒排索引"></a>2.2.2.倒排索引</h4><blockquote><p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/inverted_index.png"></p><blockquote><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul></blockquote><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/inverted_index_example.png" style="zoom: 67%;"><blockquote><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p><ol><li><p>用户输入条件<code>"华为手机"</code>进行搜索。</p></li><li><p>对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p></li><li><p>拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p></li><li><p>拿着文档id到正向索引中查找具体文档。</p></li></ol></blockquote><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/inverted_index_process.png" style="zoom: 67%;"><h4 id="2-2-3-正排索引与倒排索引优缺点"><a href="#2-2-3-正排索引与倒排索引优缺点" class="headerlink" title="2.2.3.正排索引与倒排索引优缺点"></a>2.2.3.正排索引与倒排索引优缺点</h4><blockquote><p>正排索引：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul></blockquote><blockquote><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul></blockquote><h3 id="2-3-安装"><a href="#2-3-安装" class="headerlink" title="2.3.安装"></a>2.3.安装</h3><h4 id="2-3-1-部署elasticsearch"><a href="#2-3-1-部署elasticsearch" class="headerlink" title="2.3.1.部署elasticsearch"></a>2.3.1.部署elasticsearch</h4><h5 id="2-3-1-1-创建网络"><a href="#2-3-1-1-创建网络" class="headerlink" title="2.3.1.1.创建网络"></a>2.3.1.1.创建网络</h5><blockquote><p>由于需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><pre><code class="sh">docker network create es-net</code></pre></blockquote><h5 id="2-3-1-2-加载镜像"><a href="#2-3-1-2-加载镜像" class="headerlink" title="2.3.1.2.加载镜像"></a>2.3.1.2.加载镜像</h5><blockquote><p>将镜像tar包上传到虚拟机中，运行如下命令加载：</p><pre><code class="sh"># 导入数据docker load -i es.tar</code></pre></blockquote><h5 id="2-3-1-3-运行"><a href="#2-3-1-3-运行" class="headerlink" title="2.3.1.3.运行"></a>2.3.1.3.运行</h5><blockquote><p>运行docker命令，部署单点es：</p><pre><code class="sh">docker run -d \    --name es \    -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" \    -e "discovery.type=single-node" \    -v es-data:/usr/share/elasticsearch/data \    -v es-plugins:/usr/share/elasticsearch/plugins \    --privileged \    --network es-net \    -p 9200:9200 \    -p 9300:9300 \elasticsearch:7.12.1</code></pre><ul><li><code>-e "cluster.name=es-docker-cluster"</code>：设置集群名称</li><li><code>-e "http.host=0.0.0.0"</code>：监听的地址，可以外网访问</li><li><code>-e "ES_JAVA_OPTS=-Xms512m -Xmx512m"</code>：内存大小</li><li><code>-e "discovery.type=single-node"</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>浏览器访问：<strong>http://虚拟机ip地址:9200</strong></p></blockquote><h4 id="2-3-2-部署kibana"><a href="#2-3-2-部署kibana" class="headerlink" title="2.3.2.部署kibana"></a>2.3.2.部署kibana</h4><blockquote><p>Kibana 是一个免费且开放的用户界面，能够让您对 Elasticsearch 数据进行可视化，并让您在 Elastic Stack 中进行导航。</p></blockquote><h5 id="2-3-2-1-部署"><a href="#2-3-2-1-部署" class="headerlink" title="2.3.2.1.部署"></a>2.3.2.1.部署</h5><blockquote><p>运行docker命令，部署kibana：</p><pre><code class="sh">docker run -d \--name kibana \-e ELASTICSEARCH_HOSTS=http://es:9200 \--network=es-net \-p 5601:5601  \kibana:7.12.1</code></pre><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200"</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>浏览器访问：<strong>http://虚拟机ip地址:5601</strong></p></blockquote><h4 id="2-3-3-安装IK分词器"><a href="#2-3-3-安装IK分词器" class="headerlink" title="2.3.3.安装IK分词器"></a>2.3.3.安装IK分词器</h4><h5 id="2-3-3-1-在线安装ik插件"><a href="#2-3-3-1-在线安装ik插件" class="headerlink" title="2.3.3.1.在线安装ik插件"></a>2.3.3.1.在线安装ik插件</h5><blockquote><pre><code class="sh"># 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip#退出exit#重启容器docker restart elasticsearch</code></pre></blockquote><h5 id="2-3-3-2-离线安装ik插件"><a href="#2-3-3-2-离线安装ik插件" class="headerlink" title="2.3.3.2.离线安装ik插件"></a>2.3.3.2.离线安装ik插件</h5><h6 id="2-3-3-2-1-查看数据卷目录"><a href="#2-3-3-2-1-查看数据卷目录" class="headerlink" title="2.3.3.2.1.查看数据卷目录"></a>2.3.3.2.1.查看数据卷目录</h6><blockquote><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><pre><code class="sh">docker volume inspect es-plugins</code></pre></blockquote><h6 id="2-3-3-2-2-解压缩分词器安装包"><a href="#2-3-3-2-2-解压缩分词器安装包" class="headerlink" title="2.3.3.2.2.解压缩分词器安装包"></a>2.3.3.2.2.解压缩分词器安装包</h6><h6 id="2-3-3-2-3-上传到es容器的插件数据卷中"><a href="#2-3-3-2-3-上传到es容器的插件数据卷中" class="headerlink" title="2.3.3.2.3.上传到es容器的插件数据卷中"></a>2.3.3.2.3.上传到es容器的插件数据卷中</h6><blockquote><p><code>/var/lib/docker/volumes/es-plugins/_data </code></p></blockquote><h6 id="2-3-3-2-4-重启容器"><a href="#2-3-3-2-4-重启容器" class="headerlink" title="2.3.3.2.4.重启容器"></a>2.3.3.2.4.重启容器</h6><blockquote><pre><code class="sh"># 4、重启容器docker restart es</code></pre><pre><code class="sh"># 查看es日志docker logs -f es</code></pre></blockquote><h6 id="2-3-3-2-5-测试"><a href="#2-3-3-2-5-测试" class="headerlink" title="2.3.3.2.5.测试"></a>2.3.3.2.5.测试</h6><blockquote><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>：最少切分</li><li><code>ik_max_word</code>：最细切分</li></ul><pre><code class="json">GET /_analyze{  "text": "到达世界最高城理塘,太美丽了理塘。看看远处的雪山吧家人们。哎呀，这不是丁真吗？",  "analyzer": "ik_max_word"}</code></pre></blockquote><h5 id="2-3-3-3-扩展词词典"><a href="#2-3-3-3-扩展词词典" class="headerlink" title="2.3.3.3.扩展词词典"></a>2.3.3.3.扩展词词典</h5><blockquote><p>随着互联网的发展，出现了很多新的词语，在原有的词汇列表并不存在。</p><p>因此我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p><ol><li><p>打开IK分词器config目录</p><p><code>/var/lib/docker/volumes/es-plugins/_data/ik/config/IKAnalyzer.cfg.xml</code></p></li><li><p>更改IKAnalyzer.cfg.xml配置文件的内容</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt;&lt;properties&gt;    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;    &lt;!--用户可以在这里配置自己的扩展字典 --&gt;    &lt;entry key="ext_dict"&gt;ext.dic&lt;/entry&gt;&lt;/properties&gt;</code></pre></li><li><p>创建ext.dic文件，并添加词汇</p></li><li><p>重启elasticsearch</p><pre><code class="sh">docker restart es# 查看 日志docker logs -f elasticsearch</code></pre></li><li><p>测试</p></li></ol></blockquote><h5 id="2-3-3-4-停用词词典"><a href="#2-3-3-4-停用词词典" class="headerlink" title="2.3.3.4.停用词词典"></a>2.3.3.4.停用词词典</h5><blockquote><p>在互联网项目中，很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p><ol><li><p>更改IKAnalyzer.cfg.xml配置文件的内容</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt;&lt;properties&gt;    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;    &lt;!--用户可以在这里配置自己的扩展字典 --&gt;    &lt;entry key="ext_dict"&gt;ext.dic&lt;/entry&gt;     &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;    &lt;entry key="ext_stopwords"&gt;stopword.dic&lt;/entry&gt;    &lt;!--用户可以在这里配置远程扩展字典 --&gt;    &lt;!-- &lt;entry key="remote_ext_dict"&gt;words_location&lt;/entry&gt; --&gt;    &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;    &lt;!-- &lt;entry key="remote_ext_stopwords"&gt;words_location&lt;/entry&gt; --&gt;&lt;/properties&gt;</code></pre></li><li><p>在stopword.dic添加停用词</p></li><li><p>重启elasticsearch</p></li><li><p>测试</p></li></ol></blockquote><h2 id="3-索引库操作"><a href="#3-索引库操作" class="headerlink" title="3.索引库操作"></a>3.索引库操作</h2><h3 id="3-1-mapping映射"><a href="#3-1-mapping映射" class="headerlink" title="3.1.mapping映射"></a>3.1.mapping映射</h3><blockquote><p>在 Elasticsearch 中，映射指的是 mapping，用来定义一个文档以及其所包含的字段如何被存储和索引，可以在映射中事先定义字段的数据类型、字段的权重、分词器等属性，就如同在关系型数据库中创建数据表时会设置字段的类型。</p></blockquote><h4 id="3-1-1-映射分类"><a href="#3-1-1-映射分类" class="headerlink" title="3.1.1.映射分类"></a>3.1.1.映射分类</h4><blockquote><p>在 Elasticsearch 中，映射可分为动态映射和静态映射。在关系型数据库中写入数据之前首先要建表，在建表语句中声明字段的属性，在 Elasticsearch 中，则不必如此，Elasticsearch 最重要的功能之一就是让你尽可能快地开始探索数据，文档写入 Elasticsearch 中，它会根据字段的类型自动识别，这种机制称为<strong>动态映射</strong>，而<strong>静态映射</strong>则是写入数据之前对字段的属性进行手工设置。</p></blockquote><h5 id="3-1-1-1-静态映射"><a href="#3-1-1-1-静态映射" class="headerlink" title="3.1.1.1.静态映射"></a>3.1.1.1.静态映射</h5><blockquote><p>静态映射是在创建索引时手工指定索引映射，和 SQL 中在建表语句中指定字段属性类似。相比动态映射，通过静态映射可以添加更详细、更精准的配置信息。</p></blockquote><h5 id="3-1-1-2-动态映射"><a href="#3-1-1-2-动态映射" class="headerlink" title="3.1.1.2.动态映射"></a>3.1.1.2.动态映射</h5><blockquote><p>当Elasticsearch在文档中检测到一个新字段时，默认情况下它会动态地将该字段添加到类型映射中。</p><p>在 mapping 中可以通过 <code>dynamic</code> 设置来控制是否自动新增字段，接受以下参数：</p><ul><li>true：默认值为 true，自动添加字段。</li><li>false：忽略新的字段。</li><li>strict：严格模式，发现新的字段抛出异常。</li></ul><p>下表中的字段数据类型是Elasticsearch动态检测的唯一字段数据类型。必须显式映射所有其他数据类型。</p></blockquote><table><thead><tr><th align="center">JSON格式的数据</th><th align="center"><strong><code>"dynamic":"true"</code></strong></th><th align="center"><strong><code>"dynamic":"runtime"</code></strong></th></tr></thead><tbody><tr><td align="center">null</td><td align="center">未添加字段</td><td align="center">未添加字段</td></tr><tr><td align="center">true<code>或</code>false</td><td align="center">boolean</td><td align="center">boolean</td></tr><tr><td align="center">double</td><td align="center">float</td><td align="center">double</td></tr><tr><td align="center">integer</td><td align="center">long</td><td align="center">long</td></tr><tr><td align="center">object</td><td align="center">object</td><td align="center">object</td></tr><tr><td align="center">array</td><td align="center">取决于数组中的第一个非值<code>null</code></td><td align="center">取决于数组中的第一个非值<code>null</code></td></tr><tr><td align="center">string通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/dynamic-field-mapping.html#date-detection">日期检测</a></td><td align="center">date</td><td align="center">date</td></tr><tr><td align="center"><code>string</code>通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/dynamic-field-mapping.html#numeric-detection">数字检测</a></td><td align="center">float<code>或</code>long</td><td align="center">double<code>或</code>long</td></tr><tr><td align="center">string<code>未通过检测或检测</code>date``numeric</td><td align="center">text<code>具有子字段</code>.keyword</td><td align="center">keyword</td></tr></tbody></table><h4 id="3-1-2-数据类型"><a href="#3-1-2-数据类型" class="headerlink" title="3.1.2.数据类型"></a>3.1.2.数据类型</h4><h5 id="3-1-2-1-核心类型"><a href="#3-1-2-1-核心类型" class="headerlink" title="3.1.2.1.核心类型"></a>3.1.2.1.核心类型</h5><blockquote><p>Elasticsearch 字段类型的核心类型有字符串类型、数字类型、日期类型、布尔类型、二进制类型、范围类型等。</p></blockquote><table><thead><tr><th align="center">分类</th><th align="center">具体类型</th></tr></thead><tbody><tr><td align="center">字符串类型</td><td align="center">string、text、keyword</td></tr><tr><td align="center">数字类型</td><td align="center">long、integer、short、byte、double、float、half_float、scaled_float</td></tr><tr><td align="center">日期类型</td><td align="center">date</td></tr><tr><td align="center">布尔类型</td><td align="center">boolean</td></tr><tr><td align="center">二进制类型</td><td align="center">binary</td></tr><tr><td align="center">范围类型</td><td align="center">range</td></tr></tbody></table><h5 id="3-1-2-2复合类型"><a href="#3-1-2-2复合类型" class="headerlink" title="3.1.2.2复合类型"></a>3.1.2.2复合类型</h5><blockquote><p>Elasticsearch 字段类型的复合类型有<strong>数组类型</strong>、<strong>对象类型</strong>和<strong>嵌套类型</strong>。</p></blockquote><table><thead><tr><th align="center">分类</th><th align="center">具体类型</th></tr></thead><tbody><tr><td align="center">数组类型</td><td align="center">array</td></tr><tr><td align="center">对象类型</td><td align="center">object</td></tr><tr><td align="center">嵌套类型</td><td align="center">nested</td></tr></tbody></table><h5 id="3-1-2-3-地理类型"><a href="#3-1-2-3-地理类型" class="headerlink" title="3.1.2.3.地理类型"></a>3.1.2.3.地理类型</h5><blockquote><p>Elasticsearch 的地理相关类型有<strong>地理坐标类型</strong>和<strong>地理图形类型</strong>。</p></blockquote><table><thead><tr><th align="center">分类</th><th align="center">具体类型</th></tr></thead><tbody><tr><td align="center">地理坐标类型</td><td align="center">geo_point</td></tr><tr><td align="center">地理图形类型</td><td align="center">geo_shape</td></tr></tbody></table><h5 id="3-1-2-4-特殊类型"><a href="#3-1-2-4-特殊类型" class="headerlink" title="3.1.2.4.特殊类型"></a>3.1.2.4.特殊类型</h5><table><thead><tr><th align="center">分类</th><th align="center">具体类型</th></tr></thead><tbody><tr><td align="center">IP 类型</td><td align="center">ip</td></tr><tr><td align="center">范围类型</td><td align="center">completion</td></tr><tr><td align="center">令牌计数类型</td><td align="center">token_count</td></tr><tr><td align="center">附件类型</td><td align="center">attachment</td></tr><tr><td align="center">抽取类型</td><td align="center">percolator</td></tr></tbody></table><h4 id="3-1-3-mapping属性"><a href="#3-1-3-mapping属性" class="headerlink" title="3.1.3.mapping属性"></a>3.1.3.mapping属性</h4><blockquote><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul></blockquote><h3 id="3-2-索引库的CRUD"><a href="#3-2-索引库的CRUD" class="headerlink" title="3.2.索引库的CRUD"></a>3.2.索引库的CRUD</h3><h4 id="3-2-1-创建索引库和映射"><a href="#3-2-1-创建索引库和映射" class="headerlink" title="3.2.1.创建索引库和映射"></a>3.2.1.创建索引库和映射</h4><blockquote><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><ul><li>请求方式：PUT</li><li>请求路径：/索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p><strong>格式：</strong></p><pre><code class="json">PUT&nbsp;/索引库名称{&nbsp;&nbsp;"mappings":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"properties":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"字段名":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"text",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"analyzer":&nbsp;"ik_smart"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"字段名2":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"keyword",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"index":&nbsp;"false"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"字段名3":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"properties":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"子字段":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"keyword"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},      // ...略&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre></blockquote><h4 id="3-2-2-查询索引库"><a href="#3-2-2-查询索引库" class="headerlink" title="3.2.2.查询索引库"></a>3.2.2.查询索引库</h4><blockquote><p><strong>基本语法</strong>：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式</strong>：</p><pre><code class="json">GET /索引库名</code></pre></blockquote><h4 id="3-2-3-修改索引库"><a href="#3-2-3-修改索引库" class="headerlink" title="3.2.3.修改索引库"></a>3.2.3.修改索引库</h4><blockquote><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引。索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><p><strong>语法说明</strong>：</p><pre><code class="json">PUT&nbsp;/索引库名/_mapping{&nbsp;&nbsp;"properties":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"新字段名":{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"integer"&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre></blockquote><h4 id="3-2-4-删除索引库"><a href="#3-2-4-删除索引库" class="headerlink" title="3.2.4.删除索引库"></a>3.2.4.删除索引库</h4><blockquote><p><strong>语法：</strong></p><ul><li>请求方式：DELETE</li><li>请求路径：/索引库名</li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><pre><code class="json">DELETE /索引库名</code></pre></blockquote><h2 id="4-文档操作"><a href="#4-文档操作" class="headerlink" title="4.文档操作"></a>4.文档操作</h2><h3 id="4-1-新增文档"><a href="#4-1-新增文档" class="headerlink" title="4.1.新增文档"></a>4.1.新增文档</h3><blockquote><p><strong>语法：</strong></p><pre><code class="json">POST&nbsp;/索引库名/_doc/文档id{&nbsp;&nbsp;&nbsp;&nbsp;"字段1":&nbsp;"值1",&nbsp;&nbsp;&nbsp;&nbsp;"字段2":&nbsp;"值2",&nbsp;&nbsp;&nbsp;&nbsp;"字段3":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"子属性1":&nbsp;"值3",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"子属性2":&nbsp;"值4"&nbsp;&nbsp;&nbsp;&nbsp;},    // ...}</code></pre></blockquote><h3 id="4-2-查询文档"><a href="#4-2-查询文档" class="headerlink" title="4.2.查询文档"></a>4.2.查询文档</h3><blockquote><p><strong>语法：</strong></p><pre><code class="json">GET /{索引库名称}/_doc/{id}</code></pre></blockquote><h3 id="4-3-删除文档"><a href="#4-3-删除文档" class="headerlink" title="4.3.删除文档"></a>4.3.删除文档</h3><blockquote><p><strong>语法：</strong></p><pre><code class="json">DELETE /{索引库名}/_doc/id值</code></pre></blockquote><h3 id="4-4-修改文档"><a href="#4-4-修改文档" class="headerlink" title="4.4.修改文档"></a>4.4.修改文档</h3><blockquote><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul></blockquote><h4 id="4-4-1-全量修改"><a href="#4-4-1-全量修改" class="headerlink" title="4.4.1.全量修改"></a>4.4.1.全量修改</h4><blockquote><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><p><strong>语法：</strong></p><pre><code class="json">PUT&nbsp;/{索引库名}/_doc/文档id{&nbsp;&nbsp;&nbsp;&nbsp;"字段1":&nbsp;"值1",&nbsp;&nbsp;&nbsp;&nbsp;"字段2":&nbsp;"值2",    // ... 略}</code></pre></blockquote><h4 id="4-4-2-增量修改"><a href="#4-4-2-增量修改" class="headerlink" title="4.4.2.增量修改"></a>4.4.2.增量修改</h4><blockquote><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><pre><code class="json">POST&nbsp;/{索引库名}/_update/文档id{&nbsp;&nbsp;&nbsp;&nbsp;"doc": {         "字段名":&nbsp;"新的值",    }}</code></pre></blockquote><h2 id="5-DSL查询文档"><a href="#5-DSL查询文档" class="headerlink" title="5.DSL查询文档"></a>5.DSL查询文档</h2><blockquote><p>Elasticsearch 查询语句采用基于 RESTful 风格的接口封装成 JSON 格式的对象，称之为 Query DSL。Elasticsearch 查询分类大致分为<strong>全文查询</strong>、<strong>词项查询</strong>、<strong>复合查询</strong>、<strong>嵌套查询</strong>、<strong>地理位置查询</strong>、<strong>特殊查询</strong>。</p></blockquote><h3 id="5-1-DSL查询分类"><a href="#5-1-DSL查询分类" class="headerlink" title="5.1.DSL查询分类"></a>5.1.DSL查询分类</h3><blockquote><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</li><li><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>multi_match_query</li></ul></li><li><strong>精确(term level)查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li><strong>地理（geo）查询</strong>：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul><li>bool</li><li>function_score</li></ul></li><li><strong>连接(joining)查询</strong>：在像Elasticsearch这样的分布式系统中执行完整的SQL样式的联接是非常昂贵的。相反，Elasticsearch提供了两种形式的连接，旨在水平扩展。<ul><li>nested</li><li>has_child</li><li>has_parent</li></ul></li></ul></blockquote><h3 id="5-2-全文检索查询"><a href="#5-2-全文检索查询" class="headerlink" title="5.2.全文检索查询"></a>5.2.全文检索查询</h3><h4 id="5-2-1-使用场景"><a href="#5-2-1-使用场景" class="headerlink" title="5.2.1.使用场景"></a>5.2.1.使用场景</h4><blockquote><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul></blockquote><h4 id="5-2-2-基本语法"><a href="#5-2-2-基本语法" class="headerlink" title="5.2.2.基本语法"></a>5.2.2.基本语法</h4><blockquote><p>常见的全文检索查询包括：</p><ul><li><p>match查询：单字段查询</p><p>match query用于搜索<strong>单个字段</strong>，首先针对查询语句进行解析，主要是对查询语句进行分词，分词后查询语句的任何一个词项被匹配，文档就会被搜索到，默认情况下相当于对分词后词项进行 or 匹配操作。</p></li><li><p>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</p><p>multi_match 是 match 的升级，<strong>用于搜索多个字段</strong>。查询语句为“java 编程”，查询域为 title 和 description，查询语句如下：</p></li></ul></blockquote><blockquote><p>match查询语法如下：</p><pre><code>GET /indexName/_search{  "query": {    "match": {      "FIELD": "TEXT"    }  }}</code></pre><pre><code class="json">GET article/_search{  "query": {    "match": {      "title": {        "query": "Elasticsearch 查询优化"      }    }  }}</code></pre><p>等同于 or 匹配操作，如下：</p><pre><code class="json">GET article/_search{  "query": {    "match": {      "title": {        "query": "Elasticsearch 查询优化",        "operator": "or"      }    }  }}</code></pre><p>如果想查询匹配所有关键词的文档，可以用 and 操作符连接，如下：</p><pre><code class="json">GET article/_search{  "query": {    "match": {      "title": {        "query": "Elasticsearch 查询优化",        "operator": "and"      }    }  }}</code></pre></blockquote><blockquote><p>mulit_match语法如下：</p><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"multi_match":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"query":&nbsp;"TEXT",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"fields":&nbsp;["FIELD1",&nbsp;" FIELD12"]&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre><p>multi_match 支持对要搜索的<strong>字段的名称使用通配符</strong>，<code>fields</code> 字段中的值支持通配符<code>*</code> , 设置 <code>mess*</code> 依旧可以查询出 <code>message</code> 字段中的匹配。示例如下：</p><pre><code class="json">GET books/_search{  "query": {    "multi_match": {      "query": "java 编程",      "fields": ["title", "*_name"]    }  }}</code></pre><p>在查询字段后使用 <code>^</code> 符号可以提高字段的权重，增加字段的分数 <code>_score</code> 。指定关键词出现在 title 中的权重是出现在 description 字段中的 3 倍：</p><pre><code class="json">GET books/_search{  "query": {    "multi_match": {      "query": "java 编程",      "fields": ["title^3", "description"]    }  }}</code></pre></blockquote><h3 id="5-3-精准-词项-查询"><a href="#5-3-精准-词项-查询" class="headerlink" title="5.3.精准(词项)查询"></a>5.3.精准(词项)查询</h3><blockquote><p>全文查询在执行查询之前会分析查询字符串，词项查询时对倒排索引中存储的词项进行<strong>精确匹配操作</strong>。词项级别的查询通常用于结构化数据，如数字、日期和枚举类型。</p></blockquote><h4 id="5-3-1-term-query"><a href="#5-3-1-term-query" class="headerlink" title="5.3.1.term query"></a>5.3.1.term query</h4><blockquote><p>term 查询用来查找指定字段中包含给定单词的文档，term 查询不被解析，只有查询词和文档中的词精确匹配才会被搜索到，应用场景为查询人名、地名等需要精准匹配的需求。</p><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"term":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"value":&nbsp;"VALUE"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre><p>避免 term 查询对 text 字段使用查询。<br>默认情况下，Elasticsearch 针对 text 字段的值进行解析分词，这会使查找 text 字段值的精确匹配变得困难。<br>要搜索 text 字段值，需改用 match 查询。</p></blockquote><h4 id="5-3-2-terms-query"><a href="#5-3-2-terms-query" class="headerlink" title="5.3.2.terms query"></a>5.3.2.terms query</h4><blockquote><p>terms 查询是 term 查询的升级，可以用来查询文档中包含多个词的文档。如，想查询 title 字段中包含关键词 “java” 或 “python” 的文档，构造查询语句如下：</p><pre><code class="json">{  "query": {    "terms": {      "title": ["java", "python"]    }  }}</code></pre></blockquote><h4 id="5-3-3-range-query"><a href="#5-3-3-range-query" class="headerlink" title="5.3.3.range query"></a>5.3.3.range query</h4><blockquote><p>range query 即范围查询，用于匹配在某一范围内的数值型、日期类型或者字符串型字段的文档。<strong>使用 range 查询只能查询一个字段，不能作用在多个字段上</strong>。</p><p>range 查询支持的参数有以下几种：</p><ul><li><code>gt</code> 大于，查询范围的最小值，也就是下界，但是不包含临界值。</li><li><code>gte</code> 大于等于，和 <code>gt</code> 的区别在于包含临界值。</li><li><code>lt</code> 小于，查询范围的最大值，也就是上界，但是不包含临界值。</li><li><code>lte</code> 小于等于，和 <code>lt</code> 的区别在于包含临界值。</li></ul><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"range":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"gte":&nbsp;10, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"lte":&nbsp;20 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre></blockquote><h3 id="5-4-地理坐标查询"><a href="#5-4-地理坐标查询" class="headerlink" title="5.4.地理坐标查询"></a>5.4.地理坐标查询</h3><blockquote><p>所谓的地理坐标查询，其实就是根据经纬度查询。Elasticsearch 可以对地理位置点 geo_point 类型和地理位置形状 geo_shape 类型的数据进行搜索。</p><p>官方文档：[Geo queries | Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">8.5] | Elastic</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul></blockquote><h4 id="5-4-1-矩形范围-geo-bounding-box-查询"><a href="#5-4-1-矩形范围-geo-bounding-box-查询" class="headerlink" title="5.4.1.矩形范围(geo_bounding_box)查询"></a>5.4.1.矩形范围(geo_bounding_box)查询</h4><blockquote><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档。</p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"geo_bounding_box":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"top_left":&nbsp;{ // 左上点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"lat":&nbsp;31.1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"lon":&nbsp;121.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"bottom_right":&nbsp;{ // 右下点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"lat":&nbsp;30.9,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"lon":&nbsp;121.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre></blockquote><h4 id="5-4-2-附近（geo-distance）查询"><a href="#5-4-2-附近（geo-distance）查询" class="headerlink" title="5.4.2.附近（geo_distance）查询"></a>5.4.2.附近（geo_distance）<strong>查询</strong></h4><blockquote><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件。</p><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"geo_distance":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"distance":&nbsp;"15km", // 半径&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;"31.21,121.5" // 圆心&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre></blockquote><h3 id="5-5-复合查询"><a href="#5-5-复合查询" class="headerlink" title="5.5.复合查询"></a>5.5.复合查询</h3><blockquote><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul></blockquote><h4 id="5-5-1-相关性算分"><a href="#5-5-1-相关性算分" class="headerlink" title="5.5.1.相关性算分"></a>5.5.1.相关性算分</h4><blockquote><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/TF-IDF.png"></p><blockquote><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/BM25.png"></p><blockquote><p>TF-IDF算法有一个缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/TF-IDF&amp;BM25.png"></p><h4 id="5-5-2-算分函数查询-function-score-query"><a href="#5-5-2-算分函数查询-function-score-query" class="headerlink" title="5.5.2.算分函数查询(function_score query)"></a>5.5.2.算分函数查询(function_score query)</h4><blockquote><p>function_score query 可以修改查询的文档得分，这个查询在有些情况下非常有用，比如通过评分函数计算文档得分代价较高，可以改用过滤器加自定义评分函数的方式来取代传统的评分方式。</p><p>使用 function_score query，用户需要定义一个查询和一至多个评分函数，评分函数会对查询到的每个文档分别计算得分。</p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li><li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/function_score.png"></p><h4 id="5-5-3-布尔查询-bool-query"><a href="#5-5-3-布尔查询-bool-query" class="headerlink" title="5.5.3.布尔查询(bool query)"></a>5.5.3.布尔查询(bool query)</h4><blockquote><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>假设要查询 title 中包含关键词 java，并且 price 不能高于 70，description 可以包含也可以不包含虚拟机的书籍，构造 bool 查询语句如下：</p><pre><code class="json">GET books/_search{  "query": {    "bool": {      "filter": {        "term": {          "status": 1        }      },      "must_not": {        "range": {          "price": {            "gte": 70          }        }      },      "must": {        "match": {          "title": "java"        }      },      "should": [        {          "match": {            "description": "虚拟机"          }        }      ],      "minimum_should_match": 1    }  }}</code></pre></blockquote><h3 id="5-6-搜索结果处理"><a href="#5-6-搜索结果处理" class="headerlink" title="5.6.搜索结果处理"></a>5.6.搜索结果处理</h3><blockquote><p>搜索的结果可以按照用户指定的方式去处理或展示。</p></blockquote><h4 id="5-6-1-排序"><a href="#5-6-1-排序" class="headerlink" title="5.6.1.排序"></a>5.6.1.排序</h4><blockquote><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p></blockquote><h5 id="5-6-1-1-普通字段排序"><a href="#5-6-1-1-普通字段排序" class="headerlink" title="5.6.1.1.普通字段排序"></a>5.6.1.1.普通字段排序</h5><blockquote><p>keyword、数值、日期类型排序的语法基本一致。</p><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"match_all":&nbsp;{}&nbsp;&nbsp;},&nbsp;&nbsp;"sort":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;"desc"&nbsp;&nbsp;//&nbsp;排序字段、排序方式ASC、DESC&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;]}</code></pre><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推。</p></blockquote><h5 id="5-6-1-2-地理坐标排序"><a href="#5-6-1-2-地理坐标排序" class="headerlink" title="5.6.1.2.地理坐标排序"></a>5.6.1.2.地理坐标排序</h5><blockquote><p>地理坐标排序略有不同。</p><pre><code class="json">GET&nbsp;/indexName/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"match_all":&nbsp;{}&nbsp;&nbsp;},&nbsp;&nbsp;"sort":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_geo_distance"&nbsp;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD"&nbsp;:&nbsp;"纬度，经度", // 文档中geo_point类型的字段名、目标坐标点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"order"&nbsp;:&nbsp;"asc", // 排序方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"unit"&nbsp;:&nbsp;"km" // 排序的距离单位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;]}</code></pre><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul></blockquote><h4 id="5-6-2-分页"><a href="#5-6-2-分页" class="headerlink" title="5.6.2.分页"></a>5.6.2.分页</h4><blockquote><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p></blockquote><h5 id="5-6-2-1-基本分页"><a href="#5-6-2-1-基本分页" class="headerlink" title="5.6.2.1.基本分页"></a>5.6.2.1.基本分页</h5><blockquote><p>分页的基本语法如下：</p><pre><code class="json">GET&nbsp;/hotel/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"match_all":&nbsp;{}&nbsp;&nbsp;},&nbsp;&nbsp;"from":&nbsp;0,&nbsp;//&nbsp;分页开始的位置，默认为0&nbsp;&nbsp;"size":&nbsp;10,&nbsp;//&nbsp;期望获取的文档总数&nbsp;&nbsp;"sort":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;{"price":&nbsp;"asc"}&nbsp;&nbsp;]}</code></pre></blockquote><h5 id="5-6-2-2-深度分页问题"><a href="#5-6-2-2-深度分页问题" class="headerlink" title="5.6.2.2.深度分页问题"></a>5.6.2.2.深度分页问题</h5><blockquote><p>现在查询990~1000的数据，查询逻辑为：</p><pre><code class="json">GET&nbsp;/hotel/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"match_all":&nbsp;{}&nbsp;&nbsp;},&nbsp;&nbsp;"from":&nbsp;990,&nbsp;//&nbsp;分页开始的位置，默认为0&nbsp;&nbsp;"size":&nbsp;10,&nbsp;//&nbsp;期望获取的文档总数&nbsp;&nbsp;"sort":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;{"price":&nbsp;"asc"}&nbsp;&nbsp;]}</code></pre><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5.png"></p><blockquote><p>查询TOP1000，如果es是单点模式，这并无太大影响。</p><p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p><p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p><p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p></blockquote><p><img src="/2022/09/04/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch/%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5_es%E9%9B%86%E7%BE%A4.png"></p><blockquote><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul></blockquote><h5 id="5-6-2-3-分页查询实现方案对比"><a href="#5-6-2-3-分页查询实现方案对比" class="headerlink" title="5.6.2.3.分页查询实现方案对比"></a>5.6.2.3.分页查询实现方案对比</h5><blockquote><ul><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul></blockquote><h4 id="5-6-3-高亮"><a href="#5-6-3-高亮" class="headerlink" title="5.6.3.高亮"></a>5.6.3.高亮</h4><blockquote><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示。</p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><p>实现语法：</p><pre><code class="json">GET&nbsp;/hotel/_search{&nbsp;&nbsp;"query":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"match":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;"TEXT" // 查询条件，高亮一定要使用全文检索查询&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;},&nbsp;&nbsp;"highlight":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"fields":&nbsp;{&nbsp;//&nbsp;指定要高亮的字段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"FIELD":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pre_tags":&nbsp;"&lt;em&gt;",&nbsp;&nbsp;//&nbsp;用来标记高亮字段的前置标签&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"post_tags":&nbsp;"&lt;/em&gt;"&nbsp;//&nbsp;用来标记高亮字段的后置标签&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}}</code></pre><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li></ul></blockquote><h2 id="6-RestClient查询文档"><a href="#6-RestClient查询文档" class="headerlink" title="6.RestClient查询文档"></a>6.RestClient查询文档</h2><blockquote><p>Demo地址：<a href="https://github.com/mmjzxz/elasticsearch_hotel_demo">mmjzxz/elasticsearch_hotel_demo (github.com)</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/qq_43403025/article/details/114779166">(33条消息) 信息检索——简单易懂的倒排索引（原理+例子）_土豆同学的博客-CSDN博客_倒排索引</a></li><li><a href="https://baike.baidu.com/item/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569#2_2">倒排索引_百度百科 (baidu.com)</a></li><li>[elasticsearch_百度百科 (baidu.com)</li><li><a href="https://baike.baidu.com/item/elasticsearch/3411206"></a><a href="https://www.knowledgedict.com/tutorial/elasticsearch-index-mapping.html#%E6%98%A0%E5%B0%84%E5%88%86%E7%B1%BB">Elasticsearch 索引映射类型及mapping属性详解 | 程序员笔记 (knowledgedict.com)</a></li><li><a href="https://www.knowledgedict.com/tutorial/elasticsearch-query.html">Elasticsearch（es） 查询语句语法详解 | 程序员笔记 (knowledgedict.com)</a></li><li>[Mapping | Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/mapping.html">7.12] | Elastic</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/10055039.html#%E9%80%9A%E9%85%8D%E7%AC%A6">Elasticsearch Query DSL 整理总结（四）—— Multi Match Query - ReyCG - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2022/08/13/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/13/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/08/13/KMP%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95bg.jpg"></p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><blockquote><p><code>KMP</code>算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/18686609">函数</a>本身包含了模式串的局部匹配信息。KMP算法的<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1894057">时间复杂度</a>O(m+n)。<br><a href="https://baike.baidu.com/item/KMP%E7%AE%97%E6%B3%95/10951804">kmp算法_百度百科 (baidu.com)</a></p><p>本篇文章从字符串的暴力匹配算法写起，随后阐明KMP算法的步骤流程、如何求解next数组、基于next数组对KMP算法的证明等问题，最后由字符串匹配问题联想到String类indexOf()方法，并对该方法从源码进行解析。</p></blockquote><h2 id="2-暴力匹配算法"><a href="#2-暴力匹配算法" class="headerlink" title="2.暴力匹配算法"></a>2.暴力匹配算法</h2><blockquote><p>给定两个字符串<code>source</code>(被搜索的字符串)和<code>target</code>(正在搜索的字符串)，需要查找<code>target</code>字符串在<code>source</code>字符串中出现的位置，该如何查找？</p><p>如果通过暴力匹配算法，则需要尝试将<code>source</code>中每一个字符作为开头与<code>target</code>字符串进行匹配。<br>假设当前<code>source</code>字符串匹配到i位置，<code>target</code>字符串匹配到j位置，则：</p><ul><li>若当前字符匹配成功，即<code>source[i]==target[j]</code>，则<code>i++，j++</code>，并继续匹配下一个字符；</li><li>若当前字符匹配失败，即<code>source[i]!=target[j]</code>，则i需要回溯到初始匹配字符的下一个字符，即<code>i=i-j+1</code>，j重置为0，即<code>j=0</code>，并重新进行匹配。</li></ul><p>对于长度为<code>n</code>的<code>source</code>字符串及长度为<code>m</code>的<code>target</code>字符串，时间复杂度为<code>O(m=n*m)</code>。</p></blockquote><pre><code class="java">//暴力匹配算法代码public int violentMatch(String source, String target) {    int n = source.length();    int m = target.length();    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; m; j++) {            if (source.charAt(i + j) != target.charAt(j)) {                break;            }            if (j == m - 1) {                return i;            }        }    }    return -1;}</code></pre><p><img src="/2022/08/13/KMP%E7%AE%97%E6%B3%95/violentMatch/violentMatchPS.gif"></p><h2 id="3-KMP算法"><a href="#3-KMP算法" class="headerlink" title="3.KMP算法"></a>3.KMP算法</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><blockquote><p>KMP算法是三位学者在 Brute-Force算法的基础上同时提出的模式匹配的改进算法。Brute- Force算法在模式串中有多个字符和主串中的若干个连续字符比较都相等,但最后一个字符比较不相等时,主串的比较位置需要回退。KMP算法在上述情况下,主串位置不需要回退,从而可以大大提高效率。</p></blockquote><h3 id="3-2-KMP算法流程"><a href="#3-2-KMP算法流程" class="headerlink" title="3.2 KMP算法流程"></a>3.2 KMP算法流程</h3><blockquote><ul><li>假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置</li><li>如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j] ），都令 i++，j++，继续匹配下一个字符； </li><li>如果 j != -1，且当前字符匹配失败（即 S[i] != P[j] ），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P相对于文本串 S 向右移动了 j - next [j] 位。</li><li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。</li></ul></blockquote><h3 id="3-3-前缀与后缀"><a href="#3-3-前缀与后缀" class="headerlink" title="3.3 前缀与后缀"></a>3.3 前缀与后缀</h3><h4 id="3-3-1-前缀与后缀定义"><a href="#3-3-1-前缀与后缀定义" class="headerlink" title="3.3.1 前缀与后缀定义"></a>3.3.1 前缀与后缀定义</h4><blockquote><p><strong>前缀：</strong>除了最后一个字符以外，一个字符串的全部头部组合。</p><p><strong>后缀：</strong>除了第一个字符以外，一个字符串的全部尾部组合。</p></blockquote><h4 id="3-3-2-查找最长前缀与后缀"><a href="#3-3-2-查找最长前缀与后缀" class="headerlink" title="3.3.2 查找最长前缀与后缀"></a>3.3.2 查找最长前缀与后缀</h4><blockquote><p>给定模式串为”ABCDABD”，从左至右遍历模式串，各个子串的前缀与后缀如下所示：</p></blockquote><table><thead><tr><th align="center">模式串各个子串</th><th align="center">前缀</th><th align="center">后缀</th><th align="center">最大公共元素长度</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">空</td><td align="center">空</td><td align="center">0</td></tr><tr><td align="center">AB</td><td align="center">A</td><td align="center">B</td><td align="center">0</td></tr><tr><td align="center">ABC</td><td align="center">A，AB</td><td align="center">C，BC</td><td align="center">0</td></tr><tr><td align="center">ABCD</td><td align="center">A，AB，ABC</td><td align="center">D，CD，BCD</td><td align="center">0</td></tr><tr><td align="center">ABCDA</td><td align="center">A,AB,ABC,ABCD</td><td align="center">A，DA，CDA，BCDA</td><td align="center">1</td></tr><tr><td align="center">ABCDAB</td><td align="center">A，AB，ABC，ABCD，ABCDA</td><td align="center">B，AB，DAB，CDAB，BCDAB</td><td align="center">2</td></tr><tr><td align="center">ABCDABD</td><td align="center">A，AB，ABC，ABCD，ABCDA,，BCDAB</td><td align="center">D，BD，ABD，DABD，CDABD，BCDABD</td><td align="center">0</td></tr></tbody></table><p>原模式串子串对应的各个前缀后缀的公共元素的最大长度表为：</p><table><thead><tr><th align="center">字符</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">A</th><th align="center">B</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">最大前缀后缀公共元素长度</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">0</td></tr></tbody></table><h3 id="3-4-求next数组"><a href="#3-4-求next数组" class="headerlink" title="3.4 求next数组"></a>3.4 求next数组</h3><blockquote><p>由3.3.2可知字符串”ABCDABD”各个前缀后缀的最大公共元素长度。</p><p>根据<strong>最大长度表</strong> 去求 <strong>next 数组</strong>：<strong>next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1</strong>。</p><p>求出next数组如下：</p></blockquote><table><thead><tr><th align="center">模式串</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">A</th><th align="center">B</th><th align="center">D</th></tr></thead><tbody><tr><td align="center">next</td><td align="center">-1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><blockquote><p>求”abaabcac”的next数组</p></blockquote><table><thead><tr><th align="center">模式串</th><th align="center">a</th><th align="center">b</th><th align="center">a</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">a</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">maxL</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">next</td><td align="center">-1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><h3 id="3-5-KMP算法原理及证明"><a href="#3-5-KMP算法原理及证明" class="headerlink" title="3.5 KMP算法原理及证明"></a>3.5 KMP算法原理及证明</h3><h4 id="3-5-1-KMP算法相较于暴力匹配的加速原理"><a href="#3-5-1-KMP算法相较于暴力匹配的加速原理" class="headerlink" title="3.5.1 KMP算法相较于暴力匹配的加速原理"></a>3.5.1 KMP算法相较于暴力匹配的加速原理</h4><blockquote><p>假设当前有文本串<code>source</code>与模式串<code>target</code>，需要从字符串<code>source</code>的<code>i</code>位置的字符开始判断是否能够匹配字符串<code>target</code>。假设当字符到达字符串<code>source</code>的<code>x</code>位置，字符串<code>target</code>的<code>y</code>位置时出现第一次不相等，即<code>source</code>字符串从<code>i~x-1</code>位置的字符串与<code>target</code>字符串从<code>0~y-1</code>位置的字符串匹配，则：</p><ul><li><p>根据字符串<code>暴力匹配</code>算法，当前情况只能说明以<code>i</code>位置开头的字符串无法匹配<code>target</code>字符串，因此下次匹配应该以<code>i+1</code>位置开头的字符串与<code>target</code>字符串重新开始匹配。(参考2. 暴力匹配算法)</p></li><li><p>而<code>KMP</code>算法中，根据<code>next数组</code>，可以得到<code>y</code>位置字符之前的最大前缀与最大后缀的匹配长度。假设最大前缀与最大后缀的匹配字符串的长度索引取值范围分别为<code>[0，k]</code>，<code>[t，y-1]</code>。source字符串的比对位置<code>x</code>不变，<code>target</code>字符串的比对位置<code>y</code>回跳到<code>k+1</code>位置。</p></li><li><p><strong>实质：</strong>将<code>target</code>字符串的最大后缀的第一个字符所对应的字符在<code>source</code>中的位置记为<code>j</code>。上述KMP算法匹配方式实际是将<code>target</code>字符串向右推，使得<code>target</code>字符串<code>0</code>位置与<code>source</code>字符串<code>j</code>位置相对应，检查以<code>j</code>位置字符开头的字符串是否能够匹配<code>target</code>字符串。</p><ol><li>根据最大前缀与最大后缀可知，<code>[0，k]</code>，<code>[t，y-1]</code>，<code>[j，x-1]</code>区间对应的字符串是匹配的，因此直接从字符可能不同的位置继续向下验证，即<code>k+1</code>位置与<code>x</code>位置。</li><li><code>i</code>位置与<code>j</code>位置之间以任意位置的字符开头的字符串一定不能与<code>target</code>匹配。</li></ol><p>图解参考：<a href="https://www.cnblogs.com/greyzeng/p/15317466.html">KMP算法解决字符串匹配问题 - Grey Zeng - 博客园 (cnblogs.com)</a></p></li></ul></blockquote><h4 id="3-5-2-KMP算法原理实质证明"><a href="#3-5-2-KMP算法原理实质证明" class="headerlink" title="3.5.2 KMP算法原理实质证明"></a>3.5.2 KMP算法原理实质证明</h4><blockquote><p>下面对3.5.1中实质的第2点通过next数组进行证明。</p><p><strong>证明：</strong><code>i</code>位置与<code>j</code>位置之间以任意位置的字符开头的字符串一定不能与<code>target</code>匹配。</p><blockquote><p>3.5.1中的假设不变。</p><ol><li>假设<code>i</code>位置与<code>j</code>位置之间以某个位置的字符开头的字符串能够与<code>target</code>字符串匹配，将该位置记为<code>r</code>，且<code>i&lt;r&lt;j</code>，则2。</li><li>对于<code>source</code>字符串索引位置区间<code>[r,x-1]</code>对应的字符串来说，一定与<code>target</code>字符串中<code>[0,x-1-r]</code>区间(即等量长度的字符串)对应的字符串相等。</li><li>根据3.5.1中的假设，<code>source</code>字符串中<code>[r,x-1]</code>区间对应的字符串与<code>target</code>字符串中<code>[y-x+r,y-1]</code>区间对应的字符串应该相等。</li><li>根据上述证明中第2点，第3点可推出<code>target</code>字符串中<code>[0,x-1-r]</code>区间对应的字符串与<code>target</code>字符串中<code>[y-x+r,y-1]</code>区间对应的字符串应该相等。</li><li>根据3.5.1中实质1，即根据最大前缀与最大后缀可知，<code>[0，k]</code>，<code>[t，y-1]</code>，<code>[j，x-1]</code>区间对应的字符串是匹配的。则最大匹配长度为<code>k+1==y-t==x-j</code>。</li><li>根据上述证明第4点，可以推出<code>target</code>字符串的前后缀最大匹配长度为<code>x-r</code>。根据开始的假设条件<code>i&lt;r&lt;j</code>及第5点可推出<code>x-r&gt;x-j</code>，即在<code>target</code>字符串中找到了一个比已知最大前后缀更长的前后缀。根据next数组的含义，<code>target</code>字符串中不存在比<code>x-j</code>更大的最长匹配长度，与之相矛盾。</li><li>因此<code>i</code>位置与<code>j</code>位置之间以任意位置的字符开头的字符串一定不能与<code>target</code>匹配。假设不成立，问题得证。</li></ol></blockquote></blockquote><h3 id="3-6-KMP算法代码实现"><a href="#3-6-KMP算法代码实现" class="headerlink" title="3.6 KMP算法代码实现"></a>3.6 KMP算法代码实现</h3><pre><code class="java">public class KMP {    public static int getIndexOf(String source, String target) {        if (source == null || target == null || target.length() &lt; 1 || source.length() &lt;                     target.length()) {            return -1;        }        char[] sourceChars = source.toCharArray();        char[] targetChars = target.toCharArray();        int i = 0;        int j = 0;        int[] next = getNextArray(targetChars);        while (i &lt; sourceChars.length &amp;&amp; j &lt; targetChars.length) {            if (sourceChars[i] == targetChars[j]) {                i++;                j++;            } else if (next[j] == -1) {                i++;            } else {                j = next[j];            }        }        return j == targetChars.length ? i - j : -1;    }    public static int[] getNextArray(char[] targetChars) {        if (targetChars.length == 1) {            return new int[]{-1};        }        int[] next = new int[targetChars.length];        next[0] = -1;        next[1] = 0;        int index = 2;        int cn = 0;        while (index &lt; next.length) {            if (targetChars[index - 1] == targetChars[cn]) {                next[index++] = ++cn;            } else if (cn &gt; 0) {                cn = next[cn];            } else {                next[index++] = 0;            }        }        return next;    }}</code></pre><h2 id="4-String源码indexOf-方法"><a href="#4-String源码indexOf-方法" class="headerlink" title="4.String源码indexOf()方法"></a>4.String源码indexOf()方法</h2><blockquote><p>对于字符串的匹配这个问题，在java的<code>String</code>类的源代码中提供了indexOf()方法，下面看一下源码中的<code>indexOf()</code>方法。</p></blockquote><h3 id="4-1-indexOf-方法简介"><a href="#4-1-indexOf-方法简介" class="headerlink" title="4.1 indexOf()方法简介"></a>4.1 indexOf()方法简介</h3><blockquote><p><code>indexOf()</code>是String.java中的一个方法，用于返回<code>[目标字符串]</code>在<code>[源字符串]</code>中的位置。如果源字符串中不存在目标字符串，则返回-1。</p></blockquote><h3 id="4-2-indexOf-方法形式-重载"><a href="#4-2-indexOf-方法形式-重载" class="headerlink" title="4.2 indexOf()方法形式(重载)"></a>4.2 indexOf()方法形式(重载)</h3><blockquote><p><code>indexOf()</code>方法有以下四种形式：</p><ul><li><p><strong>public int indexOf(int ch)：</strong>返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回-1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified character. If a character with value ch occurs in the character sequence represented by this String object, then the index (in Unicode code units) of the first such occurrence is returned. For values of ch in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that:</p><pre><code>   this.charAt(k) == ch   </code></pre><p>is true. For other values of ch, it is the smallest value k such that:</p><pre><code>   this.codePointAt(k) == ch   </code></pre><p>is true. In either case, if no such character occurs in this string, then -1 is returned.<br>Params:<br>ch – a character (Unicode code point).<br>Returns:<br>the index of the first occurrence of the character in the character sequence represented by this object, or -1 if the character does not occur.</p><pre><code class="java">public int indexOf(int ch) {       return indexOf(ch, 0);}</code></pre></blockquote></li><li><p><strong>public int indexOf(int ch, int fromIndex):</strong> 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.<br>If a character with value ch occurs in the character sequence represented by this String object at an index no smaller than fromIndex, then the index of the first such occurrence is returned. For values of ch in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that:</p><pre><code>   (this.charAt(k) == ch)  &amp;&amp; (k &gt;= fromIndex)   </code></pre><p>is true. For other values of ch, it is the smallest value k such that:</p><pre><code>   (this.codePointAt(k) == ch)  &amp;&amp; (k &gt;= fromIndex)   </code></pre><p>is true. In either case, if no such character occurs in this string at or after position fromIndex, then -1 is returned.<br>There is no restriction on the value of fromIndex. If it is negative, it has the same effect as if it were zero: this entire string may be searched. If it is greater than the length of this string, it has the same effect as if it were equal to the length of this string: -1 is returned.<br>All indices are specified in char values (Unicode code units).<br>Params:<br>ch – a character (Unicode code point).<br>fromIndex – the index to start the search from.<br>Returns:<br>the index of the first occurrence of the character in the character sequence represented by this object that is greater than or equal to fromIndex, or -1 if the character does not occur.</p><pre><code class="java">public int indexOf(int ch, int fromIndex) {       final int max = value.length;       if (fromIndex &lt; 0) {           fromIndex = 0;       } else if (fromIndex &gt;= max) {           // Note: fromIndex might be near -1&gt;&gt;&gt;1.           return -1;       }       if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {           // handle most cases here (ch is a BMP code point or a           // negative value (invalid code point))           final char[] value = this.value;           for (int i = fromIndex; i &lt; max; i++) {               if (value[i] == ch) {                   return i;               }           }           return -1;       } else {           return indexOfSupplementary(ch, fromIndex);       }}</code></pre><pre><code class="java">/** * Handles (rare) calls of indexOf with a supplementary character. */private int indexOfSupplementary(int ch, int fromIndex) {    if (Character.isValidCodePoint(ch)) {        final char[] value = this.value;        final char hi = Character.highSurrogate(ch);        final char lo = Character.lowSurrogate(ch);        final int max = value.length - 1;        for (int i = fromIndex; i &lt; max; i++) {            if (value[i] == hi &amp;&amp; value[i + 1] == lo) {                return i;            }        }    }    return -1;}</code></pre></blockquote></li><li><p><strong>public int indexOf(String str):</strong> 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified substring.<br>The returned index is the smallest value k for which:</p><pre><code>   this.startsWith(str, k)   </code></pre><p>If no such value of k exists, then -1 is returned.<br>Params:<br>str – the substring to search for.<br>Returns:<br>the index of the first occurrence of the specified substring, or -1 if there is no such occurrence.</p><pre><code class="java">public int indexOf(String str) {       return indexOf(str, 0);}</code></pre></blockquote></li><li><p><strong>public int indexOf(String str, int fromIndex):</strong> 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.<br>The returned index is the smallest value k for which:</p><pre><code>   k &gt;= fromIndex  &amp;&amp; this.startsWith(str, k)   </code></pre><p>If no such value of k exists, then -1 is returned.<br>Params:<br>str – the substring to search for.<br>fromIndex – the index from which to start the search.<br>Returns:<br>the index of the first occurrence of the specified substring, starting at the specified index, or -1 if there is no such occurrence.</p><pre><code class="java">public int indexOf(String str, int fromIndex) {       return indexOf(value, 0, value.length,                      str.value, 0, str.value.length, fromIndex);}</code></pre><p>Code shared by String and StringBuffer to do searches. The source is the character array being searched, and the target is the string being searched for.<br>Params:<br>source – the characters being searched.<br>sourceOffset – offset of the source string.<br>sourceCount – count of the source string.<br>target – the characters being searched for.<br>targetOffset – offset of the target string.<br>targetCount – count of the target string.<br>fromIndex – the index to begin searching from.</p><pre><code class="java">static int indexOf(char[] source, int sourceOffset, int sourceCount,                   char[] target, int targetOffset, int targetCount,                   int fromIndex) {       if (fromIndex &gt;= sourceCount) {           return (targetCount == 0 ? sourceCount : -1);       }       if (fromIndex &lt; 0) {           fromIndex = 0;       }       if (targetCount == 0) {           return fromIndex;       }       char first = target[targetOffset];       int max = sourceOffset + (sourceCount - targetCount);       for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {           /* Look for first character. */           if (source[i] != first) {               while (++i &lt;= max &amp;&amp; source[i] != first);           }           /* Found first character, now look at the rest of v2 */           if (i &lt;= max) {               int j = i + 1;               int end = j + targetCount - 1;               for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]                    == target[k]; j++, k++);               if (j == end) {                   /* Found whole string. */                   return i - sourceOffset;               }           }       }       return -1;}</code></pre></blockquote></li></ul></blockquote><h3 id="4-3-indexOf-字符串匹配算法源码分析"><a href="#4-3-indexOf-字符串匹配算法源码分析" class="headerlink" title="4.3 indexOf()字符串匹配算法源码分析"></a>4.3 indexOf()字符串匹配算法源码分析</h3><blockquote><p>对于上述<code>indexOf()</code>方法的多个重载形式，字符串匹配算法主要在<code>静态方法indexOf()</code>中实现，采用的是<code>暴力匹配</code>的方式进行。</p><p>方法参数说明：<br>source – 被搜索的字符。<br>sourceOffset – 源字符串的偏移量。<br>sourceCount – 源字符串的计数。<br>target - 正在搜索的字符。<br>targetOffset – 目标字符串的偏移量。<br>targetCount – 目标字符串的计数。<br>fromIndex – 开始搜索的索引。</p></blockquote><pre><code class="java">static int indexOf(char[] source, int sourceOffset, int sourceCount,                char[] target, int targetOffset, int targetCount,                int fromIndex) {     // 1、当开始查找位置的索引fromIndex大于等于源字符串的长度时,     /*     如果查找字符串target为空(targetCount为0),则返回被搜索的字符source的长度，即该字符的末位置;否则返        回-1,表示当前source字符串不包含target字符串;    */    if (fromIndex &gt;= sourceCount) {        return (targetCount == 0 ? sourceCount : -1);    }    // 2、如果开始查找位置的索引fromIndex小于0,则从0位置开始查找;    if (fromIndex &lt; 0) {        fromIndex = 0;    }    // 3、如果查找字符串target为空(targetCount为0),则返回fromIndex;    if (targetCount == 0) {        return fromIndex;    }    // 4、开始查找,从查找字符串target中获取第一个需要匹配的字符,标记为first;    char first = target[targetOffset];        // 4.1、计算target中的第一个字符在source字符串中可匹配的最大位置。    /*    当source字符串max位置之前(包括max位置)的所有字符开头的字符串全部匹配失败后,max+1位置及之后的字符到        source最后一个字符的长度一定小于target字符的长度,则一定匹配失败;    以source="abcabcabcd",target="adc",sourceCount=10,targetCount=3,sourceOffset=0,targetOffset=     0,fromIndex&lt;=0为例,max计算结果为0+(10-3)=7。    如下第一个for循环中,i初始化为0,i最大可达数值为max,即7。当i&gt;7时,source字符串中可匹配的字符串长度为10-       i,该字符串长度小于target字符串长度,必定不匹配。    */    int max = sourceOffset + (sourceCount - targetCount);    // 4.2、以source中前max+1个字符分别开头循环遍历,查找以该字符开头的字符串是否与target匹配。    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {        // 4.2.1、从source字符串中查找到第一个与first字符匹配的字符所在的位置        /* Look for first character. */        if (source[i] != first) {            while (++i &lt;= max &amp;&amp; source[i] != first);        }        /*        4.2.2、如果在source字符串中找到了与first字符匹配的字符，则将以当前字符开头的字符串与target字            符串进行匹配;        */        /* Found first character, now look at the rest of v2 */        // 4.2.2.1、由于在4.2.1中进行了++i操作,首先判断i是否小于等于max,原因参考4.1;        if (i &lt;= max) {            // 4.2.2.2、获取下一个需要匹配的字符的位置,标记为j;            int j = i + 1;            /*             4.2.2.3、计算成功匹配target字符串时的字符在source字符串中的最大位置,标记为end(end的最大值为               sourceCount,可结合4.1的示例计算);            */            int end = j + targetCount - 1;            // 4.2.2.4、循环遍历,从target的下一个未匹配的字符及source字符串j位置的字符开始匹配;            /*            在j未越界(4.2.2.3计算可得),若source的当前字符与target的当前字符匹配,则继续匹配下一个字符;            */            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]                 == target[k]; j++, k++);            // 4.2.2.5、如果j与end相等,则说明源字符串source匹配到目标字符串target,返回匹配开始位置            if (j == end) {                /* Found whole string. */                return i - sourceOffset;            }        }    }    // 未匹配到target字符串,返回-1。    return -1;}</code></pre><h3 id="4-4-为什么String-indexOf-方法没有使用KMP算法"><a href="#4-4-为什么String-indexOf-方法没有使用KMP算法" class="headerlink" title="4.4 为什么String.indexOf()方法没有使用KMP算法?"></a>4.4 为什么<code>String.indexOf()</code>方法没有使用KMP算法?</h3><blockquote><p>从上述分析中可知，KMP算法比暴力匹配更高效，为什么在<code>String类indexOf()方法</code>的源码中并没有使用KMP算法处理字符串匹配问题呢？</p><p><strong>参考链接：</strong><a href="https://stackoverflow.com/questions/19543547/why-does-string-indexof-not-use-kmp">java - Why does String.indexOf() not use KMP? - Stack Overflow</a></p><p><strong>翻译：</strong></p><p><strong><a href="https://stackoverflow.com/users/40342/joachim-sauer">Joachim Sauer</a>：</strong>KMP具有更好的最坏情况性能，但实际上需要一点预先计算(以生成偏移量表)。它还需要初始内存分配，这也会影响性能。<br>对于(可能)搜索相对较短字符串的常见用例，这实际上可能比原始实现要慢。<br>与此同时，对于真正庞大的数据集，您可能会使用比简单String更专门的数据结构，这意味着增加的实现(可能还有运行时)成本不值得投资。<br>请注意，在未来的Java版本中，这可能会发生变化，因为没有指定实际的算法。</p><p><strong><a href="https://stackoverflow.com/users/4516090/mike-zhang">Mike Zhang</a>：</strong>就像哈希表一样，哈希搜索通常比循环数组快，但是构建哈希结构也花费了太多的时间</p><p><strong><a href="https://stackoverflow.com/users/47984/j-random-hacker">j_random_hacker</a>：</strong>KMP和其他一些渐近有效的字符串搜索方法，如Boyer-Moore和Boyer-Moore- horspool需要额外的内存——在KMP的情况下，O(m)内存，其中m是要搜索的子字符串的大小。尽管这通常是可以接受的，但库设计者必须做出权衡，以便他们的代码在许多不同的情况下都能表现得令人满意。可能主要原因是由于KMP需要进行预处理，以及在搜索阶段更复杂的内部循环，常量因子的减速可能会使它在许多常见情况下(例如在一个长字符串中搜索小于10个字符的子字符串)比朴素的O(mn)子字符串搜索慢几倍。另外，搜索大型子字符串的人可能会发现运行时库耗尽内存，因为它试图为KMP回退函数表分配一个大型内存缓冲区。</p><p>也许更好的问题是，为什么像双向算法(<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node26.html">Two-Way Algorithm</a>)这样的O(m+n)时间，O(1)空间算法还没有被主流语言运行时库采用。同样，答案很可能是通常情况下的常数因素放缓。尽管如此，在至少一个C运行库实现中，相应的strstr()函数已经更新为使用这种算法(<a href="http://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=blob;f=lib/memmem.c;h=622a034;hb=9d8d6cd">has been updated to use this algorithm</a>)。</p><blockquote><p>我周围的人告诉我，对于短字符串KMP足够好了，但如果你需要性能，你打算用大字符串，那么不是一个好的选择。</p></blockquote><p>好吧，这与我的理解完全相反，即简单的O(mn)子字符串搜索对于短字符串足够好(可能是最好的)，但随着字符串变长，最终会输给像KMP这样渐近更快的O(m+n)算法。</p></blockquote><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ol><li>[很详尽KMP算法（厉害） - ZzUuOo666 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/zzuuoo666/p/9028287.html#3.1">https://www.cnblogs.com/zzuuoo666/p/9028287.html#3.1</a> 定义)</li><li><a href="https://zhuanlan.zhihu.com/p/76348091">七分钟理解什么是 KMP 算法 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></li><li><a href="https://www.bilibili.com/video/BV13g41157hK?p=13&amp;vd_source=fc26fbc7af16ad7ac3c98a19784df0cf">11.基础提升 有序表、并查集等_哔哩哔哩_bilibili</a></li><li><a href="https://baike.baidu.com/item/KMP%E7%AE%97%E6%B3%95/10951804">kmp算法_百度百科 (baidu.com)</a></li><li><a href="https://www.cnblogs.com/greyzeng/p/15317466.html">KMP算法解决字符串匹配问题 - Grey Zeng - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2022/07/04/ArrayList/"/>
      <url>/2022/07/04/ArrayList/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/07/04/ArrayList/bg.png"></p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h6 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h6><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。(<a href="https://pdai.tech/md/java/collection/java-collection-ArrayList.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Collection - ArrayList 源码解析 | Java 全栈知识体系 (pdai.tech)</a>)</p><h5 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h5><h6 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h6><p>参考：<a href="https://javaguide.cn/java/collection/arraylist-source-code.html#_3-4-ensurecapacity%E6%96%B9%E6%B3%95">ArrayList源码&amp;扩容机制分析 | JavaGuide</a></p><ol><li><p><code>add()</code>方法</p><p>该方法将指定元素附加到该列表的末尾，可能会导致capacity不足，因此在添加元素之前，都要进行剩余空间检查，如果需要则自动扩容。</p></li></ol><pre><code class="java">//将指定元素附加到此列表的末尾public boolean add(E e) {    //添加元素之前，先调用ensureCapacityInternal方法    ensureCapacityInternal(size + 1);  // Increments modCount!!    //添加元素其实是为数组赋值    elementData[size++] = e;    return true;}</code></pre><ol start="2"><li><code>ensureCapacityInternal()</code>方法</li></ol><pre><code class="java">private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}//得到最小扩容量private static int calculateCapacity(Object[] elementData, int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        //获取默认的容量和传入参数的较大值        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    return minCapacity;}</code></pre><ol start="3"><li><code>ensureExplicitCapacity()</code>方法</li></ol><pre><code class="java">private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    //判断是否需要扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}</code></pre><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li><li>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</li></ul><ol start="4"><li><code>grow()</code>方法</li></ol><pre><code class="java">/** * 要分配的数组的最大大小 * 一些 VM 在数组中保留一些对象标头 * 尝试分配更大的数组可能会导致 OutOfMemoryError：请求的数组大小超过 VM 限制 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) {    // overflow-conscious code    // oldCapacity为旧容量，newCapacity为新容量    int oldCapacity = elementData.length;    //将oldCapacity右移一位，其效果相当于oldCapacity /2    //扩容之后容量都会变为原来的 1.5 倍左右    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    //如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，    //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) {    //对minCapacity和MAX_ARRAY_SIZE进行比较    //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小    //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}</code></pre><h5 id="jdk17"><a href="#jdk17" class="headerlink" title="jdk17"></a>jdk17</h5><ol><li><p><code>add()</code>方法</p><p>从下面的代码可以看出，add操作的核心依旧是通过先判断容量是否充足再赋值的方式进行添加元素。但是在<code>add()</code>方法中抽取了一个重载方法。该辅助方法从<code>add(E)</code>中分离出来，以将方法字节码大小保持在35以下(<code>--XX:MaxInlineSize</code>默认值)，这有助于在C1编译循环中调用。</p></li></ol><pre><code class="java">public boolean add(E e) {    modCount++;    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s == elementData.length)        elementData = grow();    elementData[s] = e;    size = s + 1;}</code></pre><ol start="2"><li><p><code>grow()</code>方法</p><p>首先，该方法中先记录了旧容量的大小。如果当前容量大于0，或者当前数组不是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>(一个被final修饰的空数组，只有无参构造方法中elementData被赋予了<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。)</p><p>与jdk8中有所不同的是在获取新容量时，<code>grow()</code>方法中调用的为ArraysSupport类中的<code>newLength()</code>方法。<code>ArraySupport</code>里面实现了很多方法来支持数组操作，包括查找两个数组的不匹配，以及为需要重新分配地址的数组计算新的长度。<code>Arrays</code>类里面实现了很多对数组进行操作的方法（比如排序、查找）。</p></li></ol><pre><code class="java">//增加容量以确保它至少可以容纳最小容量参数指定的元素数量。//参数：minCapacity – 所需的最小容量//抛出：OutOfMemoryError – 如果 minCapacity 小于零private Object[] grow(int minCapacity) {    int oldCapacity = elementData.length;    if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        int newCapacity = ArraysSupport.newLength(oldCapacity,                              minCapacity - oldCapacity, /* minimum growth */                              oldCapacity &gt;&gt; 1           /* preferred growth */);        return elementData = Arrays.copyOf(elementData, newCapacity);    } else {        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];    }}private Object[] grow() {    return grow(size + 1);}</code></pre><ul><li>数组增长计算强加的软最大数组长度。一些 JVM（比如 HotSpot）有一个实现限制，如果请求分配一个接近 Integer.MAX_VALUE 的某个长度的数组，即使有足够的堆可用。实际限制可能取决于某些 JVM 实现特定的特征，例如对象标头大小。保守地选择软最大值以便小于可能遇到的任何实现限制。</li><li>在给定数组的当前长度、最小增长量和首选增长量的情况下计算新的数组长度。计算以溢出安全的方式完成。</li><li>此方法由包含可能需要增长以满足某些即时需求（最小增长量）但也希望请求更多空间（首选增长量）以满足未来潜在需求的数组的对象使用.返回的长度通常被限制在软最大长度，以避免达到 JVM 实现限制。但是，如果最小增长量需要，则会超过软最大值。</li><li>如果优选生长量小于最小生长量，则将最小生长量用作优选生长量。</li><li>首选长度是通过将首选增长量添加到当前长度来确定的。如果首选长度不超过软最大长度 (SOFT_MAX_ARRAY_LENGTH)，则返回首选长度。</li><li>如果首选长度超过软最大值，我们使用最小增长量。最小所需长度是通过将最小增长量添加到当前长度来确定的。如果所需的最小长度超过 Integer.MAX_VALUE，则此方法抛出 OutOfMemoryError。否则，此方法返回软最大值或最小所需长度中的较大者。</li><li>请注意，此方法本身不进行任何数组分配；它只进行数组长度增长计算。但是，如上所述，它将抛出 OutOfMemoryError。</li><li>另请注意，此方法无法检测 JVM 的实现限制，并且它可能会计算并返回一个长度值，最大（包括）可能超过 JVM 实现限制的 Integer.MAX_VALUE。在这种情况下，调用者可能会尝试使用该长度进行数组分配并遇到 OutOfMemoryError。当然，不管这个方法返回的长度值是多少，如果没有足够的堆来满足请求，调用者可能会遇到 OutOfMemoryError。</li></ul><pre><code class="java">public static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;public static int newLength(int oldLength, int minGrowth, int prefGrowth) {    // preconditions not checked because of inlining    // assert oldLength &gt;= 0    // assert minGrowth &gt; 0    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow    if (0 &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) {        return prefLength;    } else {        // put code cold in a separate method        return hugeLength(oldLength, minGrowth);    }}private static int hugeLength(int oldLength, int minGrowth) {    int minLength = oldLength + minGrowth;    if (minLength &lt; 0) { // overflow        throw new OutOfMemoryError(            "Required array length " + oldLength + " + " + minGrowth + " is too large");    } else if (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) {        return SOFT_MAX_ARRAY_LENGTH;    } else {        return minLength;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包装类</title>
      <link href="/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/bg.jpg"></p><h1 id="包装类常量池"><a href="#包装类常量池" class="headerlink" title="包装类常量池"></a>包装类常量池</h1><p>Byte，Short，Integer，Long这4中包装类默认创建了数值[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean直接返回True or False。</p><h5 id="Integer缓存源码"><a href="#Integer缓存源码" class="headerlink" title="Integer缓存源码"></a>Integer缓存源码</h5><p>返回一个表示指定int值的Integer实例。如果不需要新的Integer实例，则通常应优先使用此方法而不是构造函数Integer(int) ，因为此方法可能会通过缓存频繁请求的值来显着提高空间和时间性能。此方法将始终缓存 -128 到 127（含）范围内的值，并且可能缓存此范围之外的其他值。</p><pre><code class="java">private static class IntegerCache {    static final int low = -128;    static final int high;    static final Integer cache[];    static {        // high value may be configured by property        int h = 127;        ......    }}public static Integer valueOf(int i) {    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}</code></pre><h5 id="Character缓存源码"><a href="#Character缓存源码" class="headerlink" title="Character缓存源码"></a>Character缓存源码</h5><p>返回表示指定char值的Character实例。如果不需要新的Character实例，则通常应优先使用此方法而不是构造函数Character(char) ，因为此方法可能会通过缓存频繁请求的值来显着提高空间和时间性能。此方法将始终缓存’\u0000’到’\u007F’范围内的值，包括在内，并且可能缓存此范围之外的其他值。</p><pre><code class="java">private static class CharacterCache {    private CharacterCache(){}    static final Character cache[] = new Character[127 + 1];    static {        for (int i = 0; i &lt; cache.length; i++)            cache[i] = new Character((char)i);        }    }}public static Character valueOf(char c) {    if (c &lt;= 127) { // must cache        return CharacterCache.cache[(int)c];    }    return new Character(c);}</code></pre><h5 id="Boolean缓存源码"><a href="#Boolean缓存源码" class="headerlink" title="Boolean缓存源码"></a>Boolean缓存源码</h5><p>返回一个表示指定boolean值的Boolean实例。如果指定的boolean值为true ，则此方法返回Boolean.TRUE ；如果为false ，则此方法返回Boolean.FALSE 。如果不需要新的Boolean实例，则通常应优先使用此方法而不是构造函数Boolean(boolean) ，因为此方法可能会产生明显更好的空间和时间性能。</p><pre><code class="java">public static Boolean valueOf(boolean b) {    return (b ? TRUE : FALSE);}</code></pre><h5 id="规范事项"><a href="#规范事项" class="headerlink" title="规范事项"></a>规范事项</h5><p><img src="/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/alibaba%E8%A7%84%E8%8C%83.png"></p><h5 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h5><ul><li><p>装箱：将基本类型用它们对应的引用类型包装起来</p></li><li><p>拆箱：将包装类型转换为基本数据类型</p><pre><code class="java">Integer i = 10;//装箱int n = i; //拆箱</code></pre><pre><code class="java"> 0 bipush 10 2 invokestatic #2 &lt;java/lang/Integer.valueOf : (I)Ljava/lang/Integer;&gt; 5 astore_1 6 aload_1 7 invokevirtual #3 &lt;java/lang/Integer.intValue : ()I&gt;10 istore_211 return</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包装类 </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/bg.jpg"></p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="非分布式锁存在的问题及分布式锁原理"><a href="#非分布式锁存在的问题及分布式锁原理" class="headerlink" title="非分布式锁存在的问题及分布式锁原理"></a>非分布式锁存在的问题及分布式锁原理</h2><p>synchronized通过JVM内部的锁监视器只能保证内部多个线程之间的互斥，但在有多个JVM时，会存在多个锁监视器，就会导致多个线程获取到锁。如下图所示。</p><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E9%9D%9E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><p>为了解决上述问题，我们不能再使用JVM内部的锁监视器，而是让多个JVM使用同一个锁监视器。关键在于多进程可见及互斥。<br><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><h2 id="分布式锁定义及特性"><a href="#分布式锁定义及特性" class="headerlink" title="分布式锁定义及特性"></a>分布式锁定义及特性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>多进程可见</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ol><h2 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h2><ul><li>基于数据库<br>乐观锁：基于版本号<br>悲观锁：基于排它锁</li><li>基于Redis<br>setnx:获取锁时利用setnx的互斥特性，添加锁过期时间，避免服务宕机引起死锁；释放锁时手动释放(即删除)或超时释放。<br>Redlock机制</li><li>基于Zookeeper<br>临时有序节点:有序性实现互斥。多个线程在Zookeeper中创建节点，每个节点的ID单调递增，可以约定ID最小的获取锁成功。</li><li>基于Consul(不懂)</li></ul><table><thead><tr><th></th><th align="center">MySQl</th><th align="center">Redis</th><th align="center">Zookeeper</th></tr></thead><tbody><tr><td>互斥</td><td align="center">利用mysql本身的互斥锁机制</td><td align="center">利用setnx的互斥命令</td><td align="center">利用节点的唯一性和有序性实现互斥</td></tr><tr><td>高可用</td><td align="center">好</td><td align="center">好</td><td align="center">好</td></tr><tr><td>高性能</td><td align="center">一般</td><td align="center">好</td><td align="center">一般</td></tr><tr><td>安全性</td><td align="center">断开连接，自动释放锁</td><td align="center">利用锁超时时间，到期释放</td><td align="center">临时节点，断开连接自动释放</td></tr></tbody></table><h3 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h3><h4 id="1-方案一setnx"><a href="#1-方案一setnx" class="headerlink" title="1. 方案一setnx"></a>1. 方案一setnx</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><ul><li><p>利用setnx获取锁，并设置过期时间，保存线程标识</p><pre><code># 添加锁，利用setnx的互斥特性SETNX lock thread1# 添加锁过期时间，避免服务宕机引起的死锁EXPIRE lock 10</code></pre></li><li><p>释放锁时先判断线程标识是否与自己一致，一致则删除锁</p><pre><code># 释放锁，删除即可DEL key</code></pre></li></ul><h5 id="代码实现及相关问题分析"><a href="#代码实现及相关问题分析" class="headerlink" title="代码实现及相关问题分析"></a>代码实现及相关问题分析</h5><h6 id="初版代码"><a href="#初版代码" class="headerlink" title="初版代码"></a>初版代码</h6><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/setnx.png" style="zoom:67%;"><pre><code class="java">public interface ILock {    /**     * 尝试获取锁     * @param timeoutSec     * @return     */    boolean tryLock(long timeoutSec);    /**     * 释放锁     */    void unlock();}</code></pre><pre><code class="java">import cn.hutool.core.lang.UUID;import org.springframework.core.io.ClassPathResource;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import java.util.Collections;import java.util.concurrent.TimeUnit;public class SimpleRedisLock implements ILock {    // 分布式锁的key    private String name;    private StringRedisTemplate stringRedisTemplate;    private static final String KEY_PREFIX = "lock:";    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {        this.name = name;        this.stringRedisTemplate = stringRedisTemplate;    }    @Override    public boolean tryLock(long timeoutSec) {        //获取线程标识        long threadId = Thread.currentThread().getId();        // 尝试获取锁        Boolean success = stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec,                                   TimeUnit.SECONDS);        return Boolean.TRUE.equals(success);    }        @Override    public void unlock() {        stringRedisTemplate.delete(KEY_PREFIX+name);    }}</code></pre><pre><code class="java">//调用SimpleRedisLock实现业务Long userId = UserHolder.getUser().getId();SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);boolean isLock = lock.tryLock();// 判断是否获取锁if (!isLock) {    return Result.fail("不允许重复下单");}try {    //获取代理对象，涉及事务的失效问题    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();    return proxy.createVoucherOrder(voucherId);} finally {    lock.unlock();}</code></pre><h6 id="初版代码存在的问题分析"><a href="#初版代码存在的问题分析" class="headerlink" title="初版代码存在的问题分析"></a>初版代码存在的问题分析</h6><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%9D%E7%BA%A7%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81problem.png"></p><p>​        如上图所示，红线表示Redis锁的持有周期，线程1在执行过程中首先尝试获取锁。获取成功后线程1开始执行业务逻辑，此时若发生阻塞则会导致线程1持有锁的时间变长。这时可能出现两种情况：(1)线程1执行完业务后自己释放；(2)线程1阻塞时间超过超时时间，触发超时释放。<br>​        由于线程1持有的锁超时释放，其他线程如线程2就可以成功获取锁并开始执行自己的业务。若此时线程1被唤醒且业务完成，则需要进行释放锁，即直接删除锁。但此时释放的锁为线程2持有的锁。若线程3此时获取锁，则能够获取成功并执行相应的业务，就会导致并行执行的问题。</p><h6 id="初版代码问题解决方案"><a href="#初版代码问题解决方案" class="headerlink" title="初版代码问题解决方案"></a>初版代码问题解决方案</h6><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%9D%E7%BA%A7%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></p><p>如上图所示，在触发超时释放锁后，当前线程业务完成后释放锁时需要判断存入redis的线程标识是否与当前线程ID一致，不一致则不释放锁，一致则释放锁。流程图如下。</p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/second-version.png" style="zoom:67%;"><h6 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h6><p>在SimpleRedisLock中添加修改为下面代码</p><pre><code class="java">private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";//添加该行代码// 修改tryLock逻辑如下@Overridepublic boolean tryLock(long timeoutSec) {    //获取线程标识    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 尝试获取锁    Boolean success = stringRedisTemplate.opsForValue()        .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);}//修改unlock逻辑如下@Overridepublic void unlock() {    //获取线程标识    String threadId = ID_PREFIX + Thread.currentThread().getId();    //获取锁的线程标识    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);    //判断是否是自己的锁    if (threadId.equals(id)) {        stringRedisTemplate.delete(KEY_PREFIX + name);    }}</code></pre><h6 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h6><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98.png"><br>如上图所示，线程1首先申请获取锁并开始执行业务，业务执行完成后获取锁标识并判断是否一致。由于判断与释放并不具有原子性，因此如果判断完成后且未释放锁之前发生了阻塞，如JVM的FullGC，可能会导致锁的超时释放，线程2就可以成功获取到锁并执行业务。若此时阻塞结束，线程1恢复运行，由于判断已经执行完成且认定为现存的锁为自身持有的锁，则又一次会删除线程2持有的锁。根据初版代码的问题则可能会出现并行执行的问题。</p><h6 id="Lua脚本解决原子性问题"><a href="#Lua脚本解决原子性问题" class="headerlink" title="Lua脚本解决原子性问题"></a>Lua脚本解决原子性问题</h6><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行的原子性。基本语法：<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a><br>Redis提供的调用函数语法如下：</p><pre><code class="lua"># 执行redis命令redis.call('命令名称', 'key', '其它参数', ...)</code></pre><p>执行脚本语法如下:<br><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/eval.png"></p><p>Redis提供执行脚本的方法</p><pre><code class="java">public &lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) {        return this.scriptExecutor.execute(script, keys, args);}</code></pre><p>释放锁的业务流程如下：</p><ol><li>获取锁中的线程标识</li><li>判断是否与指定的标识(当前线程标识)一致</li><li>如果一致则释放锁(即删除锁)</li><li>如果不一致则什么都不做</li></ol><p>在resources目录下创建unlock.lua脚本</p><pre><code class="lua">--比较线程标识与锁中的标识是否一致if(redis.call('get',KEYS[1]) == ARGV[1]) then    --释放锁 del key    return redis.call('del',KEYS[1])endreturn 0</code></pre><p>SimpleRedisLock.java文件中进行如下添加修改</p><pre><code class="java">private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;//添加该行代码//添加如下静态代码块加载lua脚本static {        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));        UNLOCK_SCRIPT.setResultType(Long.class);    }//修改unlock逻辑@Overridepublic void unlock() {    //调用lua脚本    stringRedisTemplate.execute(        UNLOCK_SCRIPT,        Collections.singletonList(KEY_PREFIX + name),        ID_PREFIX + Thread.currentThread().getId());}</code></pre><h6 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h6><ul><li>利用setnx满足互斥性</li><li>利用setex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用redis集群保证高可用和高并发</li></ul><h6 id="基于setnx实现的分布式锁存在的问题"><a href="#基于setnx实现的分布式锁存在的问题" class="headerlink" title="基于setnx实现的分布式锁存在的问题"></a>基于setnx实现的分布式锁存在的问题</h6><ul><li>不可重入：同一个线程无法多次获取同一把锁</li><li>不可重试：获取锁只尝试一次就返回false，没有重试机制</li><li>超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li><li>主从一致性：如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现</li></ul><h2 id="Redisson原理"><a href="#Redisson原理" class="headerlink" title="Redisson原理"></a>Redisson原理</h2><p>官方地址：<a href="https://redisson.org/">https://redisson.org</a><br>GitHub地址：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><h3 id="Redisson分布式锁优化"><a href="#Redisson分布式锁优化" class="headerlink" title="Redisson分布式锁优化"></a>Redisson分布式锁优化</h3><ul><li><p>引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.17.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置Redisson客户端</p><p>注意导入的是redisson下的Config包</p><pre><code class="java">import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RedissonConfig {    @Bean    public RedissonClient redissonClient(){        Config config = new Config();        config.useSingleServer().setAddress("redis://192.168.139.128:6379").setPassword("20010604");        return Redisson.create(config);    }}</code></pre></li></ul><h4 id="不可重入问题-Redisson可重入锁原理"><a href="#不可重入问题-Redisson可重入锁原理" class="headerlink" title="不可重入问题(Redisson可重入锁原理)"></a>不可重入问题(Redisson可重入锁原理)</h4><p>Redisson可重入锁，是基于redis的Hash类型实现的，分别有三个参数：key、field、value。其中key还是和原来我们自定义的string类型分布式锁一样，就是前面的锁key，类似于lock:order:userId这种；而field就是原来我们自定义的string类型分布式锁的value，类似于(UUID + 线程id)的组合；而Hash类型中的value，就是该锁的重入数量。<br>根据可重入锁的原理可知，为了保证原子性和一致性，以上的操作必须使用Lua脚本来实现。</p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redisson可重入锁原理.png" style="zoom:80%;"><h4 id="Redisson分布式锁原理"><a href="#Redisson分布式锁原理" class="headerlink" title="Redisson分布式锁原理"></a>Redisson分布式锁原理</h4><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png"></p><ul><li>可重入：利用hash结构记录线程id和重入次数</li><li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制。因为采用了订阅发布功能，所以线程在获取锁失败以后的重试并不是一直尝试，而是先睡眠，等待释放锁的信号以后再被唤醒去尝试获取锁，这样很好的做到了不浪费CPU性能。</li><li>超时续约：利用watchDog，每隔一段时间（releaseTime / 3），重置超时时间。利用watchDog只有在未显式指定加锁时间（leaseTime）时才会生效。（这点很重要）若显式指定leaseTime参数，则看门狗会失效，不会自动为超时key续约。所以当我们不指定Redisson的tryLock()里的leaseTime时，那么这个锁只有在业务结束之后线程主动释放可以被释放，并不会因为线程业务阻塞而导致锁超时被释放，被其他线程获取到锁从而导致线程不安全问题。当时我们显式指定leaseTime时，WatchDog就不会生效，就会出现超时释放的情况，所以这一切都视情况来使用。</li></ul><h4 id="Redisson分布式锁主从一致性问题"><a href="#Redisson分布式锁主从一致性问题" class="headerlink" title="Redisson分布式锁主从一致性问题"></a>Redisson分布式锁主从一致性问题</h4><p>Redisson对redis集群主从一致性问题的解决方案就是采用联锁。联锁（RedissonMultiLock）对象可以将多个RLock对象关联为一个联锁，实现加锁和解锁功能。每个RLock对象实例可以来自于不同的Redi<br>sson实例。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>不可重入Redis分布式锁 </p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</p><p>缺陷：不可重入、无法重试、锁超时失效</p></li><li><p>可重入的Redis分布式锁</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待    </p><p>缺陷：redis宕机引起锁失效问题</p></li><li><p>Redisson的multiLock(联锁，主从一致性解决方案)</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</p><p>缺陷：运维成本高、实现复杂</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务失效问题</title>
      <link href="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/error.jpg"></p><h2 id="Spring中事务失效的情况"><a href="#Spring中事务失效的情况" class="headerlink" title="Spring中事务失效的情况"></a>Spring中事务失效的情况</h2><p>官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction">Data Access (spring.io)</a></p><h4 id="1-方法可见性和-Transactional-Method-visibility-and-Transactional"><a href="#1-方法可见性和-Transactional-Method-visibility-and-Transactional" class="headerlink" title="1.方法可见性和@Transactional  (Method visibility and @Transactional)"></a>1.方法可见性和@Transactional  (Method visibility and @Transactional)</h4><p>When you use transactional proxies with Spring’s standard configuration, you should apply the annotation only to methods with visibility. If you do annotate , , or package-visible methods with the annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.<br>当您将事务代理与Spring的标准配置一起使用时，您应该仅将注解应用于具有可见性的方法(public方法)。如果您？？？(不会翻译)或对包可见方法使用注解，则不会引发任何错误，但带注解的方法不会显示配置的事务设置。</p><h5 id="遇到的相关问题"><a href="#遇到的相关问题" class="headerlink" title="遇到的相关问题"></a>遇到的相关问题</h5><p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/errorSource.png"></p><p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/errorInfo.png"></p><p>private修饰的方法，spring无法生成动态代理。AOP代理分别在intercept()和invoke()方法判断是否进行事务拦截，这两个方法都会间接调用AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法来获取事务控制的相关属性。(作者：爪哇驿站 链接：<a href="https://www.zhihu.com/question/334666648/answer/2250122133">https://www.zhihu.com/question/334666648/answer/2250122133</a>)</p><pre><code class="java">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {        if (this.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {            return null;        } else {            ...        }}</code></pre><p>上述代码会导致no-public方法无法进入事务控制。</p><h4 id="2-方法内部调用"><a href="#2-方法内部调用" class="headerlink" title="2.方法内部调用"></a>2.方法内部调用</h4><p> In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with . Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code — for example, in a method.<br>在代理模式(这是默认设置)中，仅拦截通过代理传入的外部方法调用。这意味着自调用(实际上，目标对象内的方法调用目标对象的另一个方法)在运行时不会导致实际的事务生效即使调用的方法被标记。此外，代理必须完全初始化才能提供预期的行为，因此不应在初始化代码(例如，在方法中)依赖此功能。</p><h5 id="遇到的相关问题-1"><a href="#遇到的相关问题-1" class="headerlink" title="遇到的相关问题"></a>遇到的相关问题</h5><pre><code class="java">@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService {    @Override    public Result seckillVoucher(Long voucherId) {        ...        Long userId = UserHolder.getUser().getId();        synchronized (userId.toString().intern()) {            //获取代理对象，涉及事务的失效问题            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        }    }        @Transactional    public Result createVoucherOrder(Long voucherId) {        ...    }}</code></pre><p>如上述代码所示只对createVoucherOrder()加了注解，在seckillVoucher()中直接调用createVoucherOrder()时，实际是通过this.createVoucher()调用的，目标对象是没有事务功能的。这里需要通过AopContext.currentProxy()方法获取当前对象的代理对象，再通过代理对象调用createVoucherOrder()方法。</p><p>相关配置如下:<br>pom.xml文件中导入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>项目启动类添加@EnableAspectJAutoProxy(exposeProxy = true)</p><pre><code class="java">@EnableAspectJAutoProxy(exposeProxy = true)@MapperScan("com.hmdp.mapper")@SpringBootApplicationpublic class HmDianPingApplication {    public static void main(String[] args) {        SpringApplication.run(HmDianPingApplication.class, args);    }}</code></pre><h4 id="微服务中出现的事务失效问题"><a href="#微服务中出现的事务失效问题" class="headerlink" title="微服务中出现的事务失效问题"></a>微服务中出现的事务失效问题</h4><p>该部分业务涉及到的表包括pms_spu_info(spu基本信息)、pms_spu_info_desc(spu图片信息)、pms_spu_images(spu图片集合)、pms_product_attr_value(spu规格参数)、sms_spu_bounds(积分信息)、pms_sku_info(sku基本信息)、pms_sku_images(sku图片信息)、pms_sku_sale_attr_value(sku销售属性信息)、sms_sku_ladder\sms_sku_full_reduction\sms_member_price(sku的优惠、满减等信息)。<br>由于该业务涉及到其他微服务模块的功能，需要通过CouponFeignService接口进行相关功能的调用。为了保证该业务功能的原子性，为整个方法加上了<code>@Transactional</code>注解。</p><p><code>saveSpuInfo(SpuSaveVo vo)</code></p><pre><code class="java">@Transactional@Overridepublic void saveSpuInfo(SpuSaveVo vo) {    ......    couponFeignService.saveSpuBounds(spuBoundTo);    ......    couponFeignService.saveSkuReduction(skuReductionTo);}</code></pre><p><code>CouponFeignService</code></p><pre><code class="java">@FeignClient("coupon")public interface CouponFeignService {    @PostMapping("/coupon/spubounds/save")    R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo);    @PostMapping("/coupon/skufullreduction/saveinfo")    R saveSkuReduction(@RequestBody SkuReductionTo skuReductionTo);}</code></pre><p>问题重现：</p><p>将接口<code>CouponFeignService</code>中的第二个方法即<code>saveSkuReducation()</code>的请求路径与<code>CouponController</code>类中该方法的请求路径保持不一致。通过前端项目(Postman等工具)发送请求信息，由于远程调用接口的请求路径不一致导致该业务出现异常，无法远程调用该方法，因此数据库应该进行回滚操作。此时查看数据库，发现spu_bounds表中的数据并没有发生回滚，而是被插入到数据库并保存下来。<br>相关问题issue <a href="https://github.com/codingapi/tx-lcn/issues/340">feign远程调用，事务回滚不生效 · Issue #340 · codingapi/tx-lcn (github.com)</a></p><p>问题分析：</p><p><a href="https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;spm=1001.2101.3001.7020">微服务</a>中，某事务内通过feign调用多个api，但Transcational注解的事务只对本服务的流程有效，他们并不在一次事务中，feign调用的接口不会回滚。</p><p>解决方案：</p><p>对于异常回滚，异常可以传递给服务提供方，服务提供方再通过异常回滚。</p><p>分布式事务seata(待学习)</p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> Spring框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git初体验</title>
      <link href="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/gitpng.png" alt="cover"></p><h2 id="一、git-2-36-1安装"><a href="#一、git-2-36-1安装" class="headerlink" title="一、git 2.36.1安装"></a>一、git 2.36.1安装</h2><h3 id="1-1-git下载"><a href="#1-1-git下载" class="headerlink" title="1.1 git下载"></a>1.1 git下载</h3><p>官方链接：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a><br>个人下载的版本：git-2.36.1<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/git-2.36.1.jpg"></p><h3 id="1-2-git安装"><a href="#1-2-git安装" class="headerlink" title="1.2 git安装"></a>1.2 git安装</h3><h4 id="1-2-1使用许可声明"><a href="#1-2-1使用许可声明" class="headerlink" title="1.2.1使用许可声明"></a>1.2.1使用许可声明</h4><p>双击Git-2.36.1-64-bit.exe，开始安装，该页面显示第二版协议内容。<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/license.png"></p><h4 id="1-2-2-选择安装目录"><a href="#1-2-2-选择安装目录" class="headerlink" title="1.2.2 选择安装目录"></a>1.2.2 选择安装目录</h4><p>选择安装git的目录(因为装过一遍，这一步的图没了)。</p><h4 id="1-2-3-选择安装组件"><a href="#1-2-3-选择安装组件" class="headerlink" title="1.2.3 选择安装组件"></a>1.2.3 选择安装组件</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/components.png"><br>Additional icons:添加桌面图标<br>Windows Explorer integration:添加功能到鼠标右键菜单</p><ul><li>Git Bash Here:命令行模式<ul><li>Git GUI Here:图形界面</li></ul></li></ul><p>Git LFS(Large File Support):大文件支持<br>Check daily for Git for Windows updates:日常检查Git是否有更新<br>Add a Git Bash Profile to Windows Terminal:将Git Bash配置文件添加到Windows终端</p><h4 id="1-2-4-选择git默认编辑器"><a href="#1-2-4-选择git默认编辑器" class="headerlink" title="1.2.4 选择git默认编辑器"></a>1.2.4 选择git默认编辑器</h4><p>git安装程序内置提供了Vim、Notepad++、Visual Studio Code、Sublime、Notepad、Atom等编辑器。个人选择Vim编辑器。</p><h4 id="1-2-5-选择初始化新仓库的主干名字"><a href="#1-2-5-选择初始化新仓库的主干名字" class="headerlink" title="1.2.5 选择初始化新仓库的主干名字"></a>1.2.5 选择初始化新仓库的主干名字</h4><ul><li>Let Git decide:由Git自己选择，目前为”master”</li><li>很多团队已经重命名他们的默认主干为”main”，具体原因可参考<a href="https://pages.carm.cc/doc/branch-main.html">为什么Git分支开始从“master”变为“main”了？ (carm.cc)</a><br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/branch.png"></li></ul><h4 id="1-2-6-调整path环境变量"><a href="#1-2-6-调整path环境变量" class="headerlink" title="1.2.6 调整path环境变量"></a>1.2.6 调整path环境变量</h4><ul><li><p>Use Git from Git Bash only</p><p>这是最谨慎的选择，因为您的PATH根本不会被修改。你只能在Git Bash中使用Git命令行工具。</p></li><li><p>Git from the command line and also from 3rd-party software</p><p>(推荐)此选项只向您的path添加一些最小的Git包装器，以避免使用可选的Unix工具打乱您的环境。</p><p>你将能够使用Git从Git Bash，命令提示符和windowvpowershell以及任何第三方软件寻找Git在PATH。</p></li><li><p>use Git and optional Unix tools from the Command Prompt</p><p>Git和可选的Unix工具都将被添加到你的PATH中。警告:这将覆盖Windows工具，如“查找”和“排序”。如果您了解其中的含义，请仅使用此选项。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/PathEnvironment.png"></p></li></ul><h4 id="1-2-7-选择SSH执行文件"><a href="#1-2-7-选择SSH执行文件" class="headerlink" title="1.2.7 选择SSH执行文件"></a>1.2.7 选择SSH执行文件</h4><ul><li><p>Use bundled openSSH<br>这使用了Git附带的ssh.exe。</p></li><li><p>Use external OpenSSH</p><p>这将使用外部ssh.exe。Git不会生成自己的OpenSSH。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/SSH.png"></p></li></ul><h4 id="1-2-8-选择HTTPS后端传输"><a href="#1-2-8-选择HTTPS后端传输" class="headerlink" title="1.2.8 选择HTTPS后端传输"></a>1.2.8 选择HTTPS后端传输</h4><ul><li><p>use the openSSL library</p><p>服务器证书将使用ca-bundle.crt文件进行验证。</p></li><li><p>use the native Windows secure Channel library</p><p>将使用Windows证书存储来验证服务器证书。这个选项也允许你使用你公司的内部根CA证书，例如通过Active Directory域服务分发。</p></li></ul><h5 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h5><p>链接：<a href="https://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr">git - OpenSSL 和本机 Windows 安全通道库有什么区别 - 堆栈溢出 (stackoverflow.com)</a></p><p>如果在具有企业托管证书的组织中使用 git，则需要使用安全通道。如果您仅使用 git 访问公共存储库（如 GitHub），或者您的组织不管理自己的证书，那么使用 SSL 后端（它们只是同一协议的不同实现）都可以。<br>从 <a href="https://github.com/git/git/commit/21084e84a418e0a6c4da72f632c5cd99386bd64b">https://github.com/git/git/commit/21084e84a418e0a6c4da72f632c5cd99386bd64b</a></p><pre><code>从版本 7.56.0 开始，curl 支持使用多个 SSL 后端进行编译。此修补程序添加了该功能的 Git 端：通过将 http.sslBackend 设置为“openssl”或“schannel”，Git for Windows 现在可以在运行时选择 SSL 后端。这在 Windows 上派上用场，因为安全通道（“schannel”）是访问 Windows 凭据存储的本机解决方案，从而允许企业范围的证书管理。由于历史原因，Git for Windows仍然需要支持OpenSSL，因为它以前是Git for Windows中唯一支持的SSL后端近十年了。该补丁已经在Git for Windows中进行了一年多，并且被认为是成熟的。</code></pre><h4 id="1-2-9-配置行尾符号转换"><a href="#1-2-9-配置行尾符号转换" class="headerlink" title="1.2.9 配置行尾符号转换"></a>1.2.9 配置行尾符号转换</h4><ul><li><p>Checkout Windows-style,commit Unix-style line endings</p><p>Git在检出文本文件时会将LF转换为CRLF。在提交文本文件时，会将CRLF转换为LT。对于跨平台的项目，这是Windows上的推荐设置(“core.autocrlf”设置为“true”)。</p></li><li><p>Checkout as-is,commit Unix-style line endings</p><p>当签出文本文件时，Git不会执行任何转换。提交文本文件时，CRLF将被转换为LF。对于跨平台项目，这是Unix上的推荐设置(“core.autocrlf”设置为“input”)。</p></li><li><p>Checkout as-is,commit as-is</p><p>当签出或提交文本文件时，Git不会执行任何转换。对于跨平台项目，不建议选择此选项(“core.autocrlf”设置为“false”)。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/line-ending.png"></p></li></ul><h4 id="1-2-10-配置终端模拟器以与-Git-Bash一起使用"><a href="#1-2-10-配置终端模拟器以与-Git-Bash一起使用" class="headerlink" title="1.2.10 配置终端模拟器以与 Git Bash一起使用"></a>1.2.10 配置终端模拟器以与 Git Bash一起使用</h4><ul><li><p>Use MinTTY (the default terminal of MSYS2)</p><p>Git Bash将使用MinTTY作为终端模拟器，它具有一个可调整大小的窗口非矩形选择和Unicode字体。Windows控制台程序(suc作为交互式Python)必须通过winpty启动才能在MinTTY工作。</p></li><li><p>Use Windows’default console window</p><p>Git将使用Windows的默认控制台窗口(“cmd.exe”)与Win32控制台程序，如交互式Python或node.js，但有一个非常有限的默认回滚，需要配置为使用Unicode字体以正确显示非ascii字符，并且在Windows 10之前为其窗口不能自由地调整大小，它只允许矩形文本选择。<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/terminalAndBash.png"></p></li></ul><h4 id="1-2-11-选择默认的”git-pull”行为-默认即可"><a href="#1-2-11-选择默认的”git-pull”行为-默认即可" class="headerlink" title="1.2.11 选择默认的”git pull”行为(默认即可)"></a>1.2.11 选择默认的”git pull”行为(默认即可)</h4><ul><li><p>Default (fast-forward or merge)</p><p>这是git pull的标准行为:在可能的情况下，将当前分支快进到获取的分支，否则创建一个merge commit。</p></li><li><p>Rebase</p><p>将当前分支重新基于获取的分支。如果没有对rebase的本地提交，这相当于快进。</p></li><li><p>Only ever fast-forward</p><p>快进到获取的分支。如果不可能，就失败。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/git_pull.png"></p></li></ul><h4 id="1-2-12-选择一个凭证助手"><a href="#1-2-12-选择一个凭证助手" class="headerlink" title="1.2.12 选择一个凭证助手"></a>1.2.12 选择一个凭证助手</h4><ul><li><p>Git Credential Manager</p><p>使用跨平台的Git Credential Manager。<br>在这里查看Git凭据管理器未来的更多信息。</p></li><li><p>None</p><p>不要使用凭据助手。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/credentialHelper.png"></p></li></ul><p>Git Credential Manager提供登录凭证帮助，Git 有时需要用户的凭据才能执行操作；例如，可能需要输入用户名和密码才能通过 HTTP 访问远程存储库。</p><h4 id="1-2-13-配置额外选项"><a href="#1-2-13-配置额外选项" class="headerlink" title="1.2.13 配置额外选项"></a>1.2.13 配置额外选项</h4><ul><li><p>Enable file system caching</p><p>对于某些操作，文件系统数据将被批量读取并缓存在内存中(“core.fscache”设置为“true”)。这提供了显著的性能提升。</p></li><li><p>Enable symbolic links</p><p>启用符号链接(需要SeCreateSymbolicLink权限)。 请注意，现有的存储库不受此设置的影响。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/extra_options.png"></p></li></ul><h4 id="1-2-14-配置实验性选项"><a href="#1-2-14-配置实验性选项" class="headerlink" title="1.2.14 配置实验性选项"></a>1.2.14 配置实验性选项</h4><ul><li><p>Enable experimental support for pseudo consoles.</p><p>这允许在Git Bash窗口中运行本机控制台程序，如Node或Python，而无需使用winpty，但它仍有已知的缺陷。</p></li><li><p>Enable experimental built-in file system monitor</p><p>自动运行内置的文件系统监视器，以加速包含许多文件的工作树中的常见操作，如git status ‘、git add ‘、git commit ‘等。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/experimental_options.png"></p></li></ul><h3 id="二、idea安装git"><a href="#二、idea安装git" class="headerlink" title="二、idea安装git"></a>二、idea安装git</h3><h4 id="2-1-打开IDEA，选择File-settings-Version-Control-Git"><a href="#2-1-打开IDEA，选择File-settings-Version-Control-Git" class="headerlink" title="2.1 打开IDEA，选择File-settings-Version Control-Git"></a>2.1 打开IDEA，选择File-settings-Version Control-Git</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.1.png"></p><h4 id="2-2-Path-to-Git-executable右侧选择文件夹标志-Browse…-Shift-Enter-选择Git安装目录下bin-git-exe"><a href="#2-2-Path-to-Git-executable右侧选择文件夹标志-Browse…-Shift-Enter-选择Git安装目录下bin-git-exe" class="headerlink" title="2.2 Path to Git executable右侧选择文件夹标志(Browse…(Shift+Enter)),选择Git安装目录下bin-git.exe"></a>2.2 Path to Git executable右侧选择文件夹标志(Browse…(Shift+Enter)),选择Git安装目录下bin-git.exe</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.2.png"></p><h4 id="2-3-Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set-this-path-only-for-the-current-project下显示版本信息。"><a href="#2-3-Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set-this-path-only-for-the-current-project下显示版本信息。" class="headerlink" title="2.3 Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set this path only for the current project下显示版本信息。"></a>2.3 Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set this path only for the current project下显示版本信息。</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.3.png"></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/mukes/article/details/115693833">(25条消息) Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/23/hello-world/"/>
      <url>/2022/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
