<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KMP算法</title>
      <link href="/2022/08/13/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/13/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/08/13/KMP%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95bg.jpg"></p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote><p><code>KMP</code>算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/18686609">函数</a>本身包含了模式串的局部匹配信息。KMP算法的<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1894057">时间复杂度</a>O(m+n)。<br><a href="https://baike.baidu.com/item/KMP%E7%AE%97%E6%B3%95/10951804">kmp算法_百度百科 (baidu.com)</a></p></blockquote><h2 id="2-暴力匹配算法"><a href="#2-暴力匹配算法" class="headerlink" title="2. 暴力匹配算法"></a>2. 暴力匹配算法</h2><blockquote><p>给定两个字符串<code>source</code>(被搜索的字符串)和<code>target</code>(正在搜索的字符串)，需要查找<code>target</code>字符串在<code>source</code>字符串中出现的位置，该如何查找？</p><p>如果通过暴力匹配算法，则需要尝试将<code>source</code>中每一个字符作为开头与<code>target</code>字符串进行匹配。<br>假设当前<code>source</code>字符串匹配到i位置，<code>target</code>字符串匹配到j位置，则：</p><ul><li>若当前字符匹配成功，即<code>source[i]==target[j]</code>，则<code>i++，j++</code>，并继续匹配下一个字符；</li><li>若当前字符匹配失败，即<code>source[i]!=target[j]</code>，则i需要回溯到初始匹配字符的下一个字符，即<code>i=i-j+1</code>，j重置为0，即<code>j=0</code>，并重新进行匹配。</li></ul><p>对于长度为<code>n</code>的<code>source</code>字符串及长度为<code>m</code>的<code>target</code>字符串，时间复杂度为<code>O(m=n*m)</code>。</p></blockquote><pre><code class="java">//暴力匹配算法代码public int violentMatch(String source, String target) {    int n = source.length();    int m = target.length();    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; m; j++) {            if (source.charAt(i + j) != target.charAt(j)) {                break;            }            if (j == m - 1) {                return i;            }        }    }    return -1;}</code></pre><h2 id="3-KMP算法"><a href="#3-KMP算法" class="headerlink" title="3. KMP算法"></a>3. KMP算法</h2><h2 id="4-String源码indexOf-方法"><a href="#4-String源码indexOf-方法" class="headerlink" title="4. String源码indexOf()方法"></a>4. String源码indexOf()方法</h2><blockquote><p>对于字符串的匹配这个问题，在java的<code>String</code>类的源代码中提供了indexOf()方法，下面看一下源码中的<code>indexOf()</code>方法。</p></blockquote><h3 id="4-1-indexOf-方法简介"><a href="#4-1-indexOf-方法简介" class="headerlink" title="4.1 indexOf()方法简介"></a>4.1 indexOf()方法简介</h3><blockquote><p><code>indexOf()</code>是String.java中的一个方法，用于返回<code>[目标字符串]</code>在<code>[源字符串]</code>中的位置。如果源字符串中不存在目标字符串，则返回-1。</p></blockquote><h3 id="4-2-indexOf-方法形式-重载"><a href="#4-2-indexOf-方法形式-重载" class="headerlink" title="4.2 indexOf()方法形式(重载)"></a>4.2 indexOf()方法形式(重载)</h3><blockquote><p><code>indexOf()</code>方法有以下四种形式：</p><ul><li><p><strong>public int indexOf(int ch)：</strong>返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回-1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified character. If a character with value ch occurs in the character sequence represented by this String object, then the index (in Unicode code units) of the first such occurrence is returned. For values of ch in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that:</p><pre><code>   this.charAt(k) == ch   </code></pre><p>is true. For other values of ch, it is the smallest value k such that:</p><pre><code>   this.codePointAt(k) == ch   </code></pre><p>is true. In either case, if no such character occurs in this string, then -1 is returned.<br>Params:<br>ch – a character (Unicode code point).<br>Returns:<br>the index of the first occurrence of the character in the character sequence represented by this object, or -1 if the character does not occur.</p><pre><code class="java">public int indexOf(int ch) {       return indexOf(ch, 0);}</code></pre></blockquote></li><li><p><strong>public int indexOf(int ch, int fromIndex):</strong> 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.<br>If a character with value ch occurs in the character sequence represented by this String object at an index no smaller than fromIndex, then the index of the first such occurrence is returned. For values of ch in the range from 0 to 0xFFFF (inclusive), this is the smallest value k such that:</p><pre><code>   (this.charAt(k) == ch)  &amp;&amp; (k &gt;= fromIndex)   </code></pre><p>is true. For other values of ch, it is the smallest value k such that:</p><pre><code>   (this.codePointAt(k) == ch)  &amp;&amp; (k &gt;= fromIndex)   </code></pre><p>is true. In either case, if no such character occurs in this string at or after position fromIndex, then -1 is returned.<br>There is no restriction on the value of fromIndex. If it is negative, it has the same effect as if it were zero: this entire string may be searched. If it is greater than the length of this string, it has the same effect as if it were equal to the length of this string: -1 is returned.<br>All indices are specified in char values (Unicode code units).<br>Params:<br>ch – a character (Unicode code point).<br>fromIndex – the index to start the search from.<br>Returns:<br>the index of the first occurrence of the character in the character sequence represented by this object that is greater than or equal to fromIndex, or -1 if the character does not occur.</p><pre><code class="java">public int indexOf(int ch, int fromIndex) {       final int max = value.length;       if (fromIndex &lt; 0) {           fromIndex = 0;       } else if (fromIndex &gt;= max) {           // Note: fromIndex might be near -1&gt;&gt;&gt;1.           return -1;       }       if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {           // handle most cases here (ch is a BMP code point or a           // negative value (invalid code point))           final char[] value = this.value;           for (int i = fromIndex; i &lt; max; i++) {               if (value[i] == ch) {                   return i;               }           }           return -1;       } else {           return indexOfSupplementary(ch, fromIndex);       }}</code></pre><pre><code class="java">/** * Handles (rare) calls of indexOf with a supplementary character. */private int indexOfSupplementary(int ch, int fromIndex) {    if (Character.isValidCodePoint(ch)) {        final char[] value = this.value;        final char hi = Character.highSurrogate(ch);        final char lo = Character.lowSurrogate(ch);        final int max = value.length - 1;        for (int i = fromIndex; i &lt; max; i++) {            if (value[i] == hi &amp;&amp; value[i + 1] == lo) {                return i;            }        }    }    return -1;}</code></pre></blockquote></li><li><p><strong>public int indexOf(String str):</strong> 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified substring.<br>The returned index is the smallest value k for which:</p><pre><code>   this.startsWith(str, k)   </code></pre><p>If no such value of k exists, then -1 is returned.<br>Params:<br>str – the substring to search for.<br>Returns:<br>the index of the first occurrence of the specified substring, or -1 if there is no such occurrence.</p><pre><code class="java">public int indexOf(String str) {       return indexOf(str, 0);}</code></pre></blockquote></li><li><p><strong>public int indexOf(String str, int fromIndex):</strong> 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p><blockquote><p>Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.<br>The returned index is the smallest value k for which:</p><pre><code>   k &gt;= fromIndex  &amp;&amp; this.startsWith(str, k)   </code></pre><p>If no such value of k exists, then -1 is returned.<br>Params:<br>str – the substring to search for.<br>fromIndex – the index from which to start the search.<br>Returns:<br>the index of the first occurrence of the specified substring, starting at the specified index, or -1 if there is no such occurrence.</p><pre><code class="java">public int indexOf(String str, int fromIndex) {       return indexOf(value, 0, value.length,                      str.value, 0, str.value.length, fromIndex);}</code></pre><p>Code shared by String and StringBuffer to do searches. The source is the character array being searched, and the target is the string being searched for.<br>Params:<br>source – the characters being searched.<br>sourceOffset – offset of the source string.<br>sourceCount – count of the source string.<br>target – the characters being searched for.<br>targetOffset – offset of the target string.<br>targetCount – count of the target string.<br>fromIndex – the index to begin searching from.</p><pre><code class="java">static int indexOf(char[] source, int sourceOffset, int sourceCount,                   char[] target, int targetOffset, int targetCount,                   int fromIndex) {       if (fromIndex &gt;= sourceCount) {           return (targetCount == 0 ? sourceCount : -1);       }       if (fromIndex &lt; 0) {           fromIndex = 0;       }       if (targetCount == 0) {           return fromIndex;       }       char first = target[targetOffset];       int max = sourceOffset + (sourceCount - targetCount);       for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {           /* Look for first character. */           if (source[i] != first) {               while (++i &lt;= max &amp;&amp; source[i] != first);           }           /* Found first character, now look at the rest of v2 */           if (i &lt;= max) {               int j = i + 1;               int end = j + targetCount - 1;               for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]                    == target[k]; j++, k++);               if (j == end) {                   /* Found whole string. */                   return i - sourceOffset;               }           }       }       return -1;}</code></pre></blockquote></li></ul></blockquote><h3 id="4-3-indexOf-字符串匹配算法源码分析"><a href="#4-3-indexOf-字符串匹配算法源码分析" class="headerlink" title="4.3 indexOf()字符串匹配算法源码分析"></a>4.3 indexOf()字符串匹配算法源码分析</h3><blockquote><p>对于上述<code>indexOf()</code>方法的多个重载形式，字符串匹配算法主要在<code>静态方法indexOf()</code>中实现，采用的是<code>暴力匹配</code>的方式进行。</p><p>方法参数说明：<br>source – 被搜索的字符。<br>sourceOffset – 源字符串的偏移量。<br>sourceCount – 源字符串的计数。<br>target - 正在搜索的字符。<br>targetOffset – 目标字符串的偏移量。<br>targetCount – 目标字符串的计数。<br>fromIndex – 开始搜索的索引。</p></blockquote><pre><code class="java">static int indexOf(char[] source, int sourceOffset, int sourceCount,                char[] target, int targetOffset, int targetCount,                int fromIndex) {     // 1、当开始查找位置的索引fromIndex大于等于源字符串的长度时,     /*     如果查找字符串target为空(targetCount为0),则返回被搜索的字符source的长度，即该字符的末位置;    否则返回-1,表示当前source字符串不包含target字符串;    */    if (fromIndex &gt;= sourceCount) {        return (targetCount == 0 ? sourceCount : -1);    }    // 2、如果开始查找位置的索引fromIndex小于0,则从0位置开始查找;    if (fromIndex &lt; 0) {        fromIndex = 0;    }    // 3、如果查找字符串target为空(targetCount为0),则返回fromIndex;    if (targetCount == 0) {        return fromIndex;    }    // 4、开始查找,从查找字符串target中获取第一个需要匹配的字符,标记为first;    char first = target[targetOffset];        // 4.1、计算target中的第一个字符在source字符串中可匹配的最大位置。    /*    当source字符串max位置之前(包括max位置)的所有字符开头的字符串全部匹配失败后,max+1位置及之后的字符到        source最后一个字符的长度一定小于target字符的长度,则一定匹配失败;    以source="abcabcabcd",target="adc",sourceCount=10,targetCount=3,sourceOffset=0,targetOffset=     0,fromIndex&lt;=0为例,max计算结果为0+(10-3)=7。    如下第一个for循环中,i初始化为0,i最大可达数值为max,即7。当i&gt;7时,source字符串中可匹配的字符串长度为10-       i,该字符串长度小于target字符串长度,必定不匹配。    */    int max = sourceOffset + (sourceCount - targetCount);    // 4.2、以source中前max+1个字符分别开头循环遍历,查找以该字符开头的字符串是否与target匹配。    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {        // 4.2.1、从source字符串中查找到第一个与first字符匹配的字符所在的位置        /* Look for first character. */        if (source[i] != first) {            while (++i &lt;= max &amp;&amp; source[i] != first);        }        /*        4.2.2、如果在source字符串中找到了与first字符匹配的字符，则将以当前字符开头的字符串与target字            符串进行匹配;        */        /* Found first character, now look at the rest of v2 */        // 4.2.2.1、由于在4.2.1中进行了++i操作,首先判断i是否小于等于max,原因参考4.1;        if (i &lt;= max) {            // 4.2.2.2、获取下一个需要匹配的字符的位置,标记为j;            int j = i + 1;            /*             4.2.2.3、计算成功匹配target字符串时的字符在source字符串中的最大位置,标记为end(end的最大值为               sourceCount,可结合4.1的示例计算);            */            int end = j + targetCount - 1;            // 4.2.2.4、循环遍历,从target的下一个未匹配的字符及source字符串j位置的字符开始匹配;            /*            在j未越界(4.2.2.3计算可得),若source的当前字符与target的当前字符匹配,则继续匹配下一个字符;            */            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]                 == target[k]; j++, k++);            // 4.2.2.5、如果j与end相等,则说明源字符串source匹配到目标字符串target,返回匹配开始位置            if (j == end) {                /* Found whole string. */                return i - sourceOffset;            }        }    }    // 未匹配到target字符串,返回-1。    return -1;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2022/07/04/ArrayList/"/>
      <url>/2022/07/04/ArrayList/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/07/04/ArrayList/bg.png"></p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h6 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h6><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。(<a href="https://pdai.tech/md/java/collection/java-collection-ArrayList.html#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Collection - ArrayList 源码解析 | Java 全栈知识体系 (pdai.tech)</a>)</p><h5 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h5><h6 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h6><p>参考：<a href="https://javaguide.cn/java/collection/arraylist-source-code.html#_3-4-ensurecapacity%E6%96%B9%E6%B3%95">ArrayList源码&amp;扩容机制分析 | JavaGuide</a></p><ol><li><p><code>add()</code>方法</p><p>该方法将指定元素附加到该列表的末尾，可能会导致capacity不足，因此在添加元素之前，都要进行剩余空间检查，如果需要则自动扩容。</p></li></ol><pre><code class="java">//将指定元素附加到此列表的末尾public boolean add(E e) {    //添加元素之前，先调用ensureCapacityInternal方法    ensureCapacityInternal(size + 1);  // Increments modCount!!    //添加元素其实是为数组赋值    elementData[size++] = e;    return true;}</code></pre><ol start="2"><li><code>ensureCapacityInternal()</code>方法</li></ol><pre><code class="java">private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}//得到最小扩容量private static int calculateCapacity(Object[] elementData, int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        //获取默认的容量和传入参数的较大值        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    return minCapacity;}</code></pre><ol start="3"><li><code>ensureExplicitCapacity()</code>方法</li></ol><pre><code class="java">private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    //判断是否需要扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}</code></pre><ul><li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li><li>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</li></ul><ol start="4"><li><code>grow()</code>方法</li></ol><pre><code class="java">/** * 要分配的数组的最大大小 * 一些 VM 在数组中保留一些对象标头 * 尝试分配更大的数组可能会导致 OutOfMemoryError：请求的数组大小超过 VM 限制 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) {    // overflow-conscious code    // oldCapacity为旧容量，newCapacity为新容量    int oldCapacity = elementData.length;    //将oldCapacity右移一位，其效果相当于oldCapacity /2    //扩容之后容量都会变为原来的 1.5 倍左右    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    //如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，    //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) {    //对minCapacity和MAX_ARRAY_SIZE进行比较    //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小    //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}</code></pre><h5 id="jdk17"><a href="#jdk17" class="headerlink" title="jdk17"></a>jdk17</h5><ol><li><p><code>add()</code>方法</p><p>从下面的代码可以看出，add操作的核心依旧是通过先判断容量是否充足再赋值的方式进行添加元素。但是在<code>add()</code>方法中抽取了一个重载方法。该辅助方法从<code>add(E)</code>中分离出来，以将方法字节码大小保持在35以下(<code>--XX:MaxInlineSize</code>默认值)，这有助于在C1编译循环中调用。</p></li></ol><pre><code class="java">public boolean add(E e) {    modCount++;    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s == elementData.length)        elementData = grow();    elementData[s] = e;    size = s + 1;}</code></pre><ol start="2"><li><p><code>grow()</code>方法</p><p>首先，该方法中先记录了旧容量的大小。如果当前容量大于0，或者当前数组不是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>(一个被final修饰的空数组，只有无参构造方法中elementData被赋予了<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。)</p><p>与jdk8中有所不同的是在获取新容量时，<code>grow()</code>方法中调用的为ArraysSupport类中的<code>newLength()</code>方法。<code>ArraySupport</code>里面实现了很多方法来支持数组操作，包括查找两个数组的不匹配，以及为需要重新分配地址的数组计算新的长度。<code>Arrays</code>类里面实现了很多对数组进行操作的方法（比如排序、查找）。</p></li></ol><pre><code class="java">//增加容量以确保它至少可以容纳最小容量参数指定的元素数量。//参数：minCapacity – 所需的最小容量//抛出：OutOfMemoryError – 如果 minCapacity 小于零private Object[] grow(int minCapacity) {    int oldCapacity = elementData.length;    if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        int newCapacity = ArraysSupport.newLength(oldCapacity,                              minCapacity - oldCapacity, /* minimum growth */                              oldCapacity &gt;&gt; 1           /* preferred growth */);        return elementData = Arrays.copyOf(elementData, newCapacity);    } else {        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];    }}private Object[] grow() {    return grow(size + 1);}</code></pre><ul><li>数组增长计算强加的软最大数组长度。一些 JVM（比如 HotSpot）有一个实现限制，如果请求分配一个接近 Integer.MAX_VALUE 的某个长度的数组，即使有足够的堆可用。实际限制可能取决于某些 JVM 实现特定的特征，例如对象标头大小。保守地选择软最大值以便小于可能遇到的任何实现限制。</li><li>在给定数组的当前长度、最小增长量和首选增长量的情况下计算新的数组长度。计算以溢出安全的方式完成。</li><li>此方法由包含可能需要增长以满足某些即时需求（最小增长量）但也希望请求更多空间（首选增长量）以满足未来潜在需求的数组的对象使用.返回的长度通常被限制在软最大长度，以避免达到 JVM 实现限制。但是，如果最小增长量需要，则会超过软最大值。</li><li>如果优选生长量小于最小生长量，则将最小生长量用作优选生长量。</li><li>首选长度是通过将首选增长量添加到当前长度来确定的。如果首选长度不超过软最大长度 (SOFT_MAX_ARRAY_LENGTH)，则返回首选长度。</li><li>如果首选长度超过软最大值，我们使用最小增长量。最小所需长度是通过将最小增长量添加到当前长度来确定的。如果所需的最小长度超过 Integer.MAX_VALUE，则此方法抛出 OutOfMemoryError。否则，此方法返回软最大值或最小所需长度中的较大者。</li><li>请注意，此方法本身不进行任何数组分配；它只进行数组长度增长计算。但是，如上所述，它将抛出 OutOfMemoryError。</li><li>另请注意，此方法无法检测 JVM 的实现限制，并且它可能会计算并返回一个长度值，最大（包括）可能超过 JVM 实现限制的 Integer.MAX_VALUE。在这种情况下，调用者可能会尝试使用该长度进行数组分配并遇到 OutOfMemoryError。当然，不管这个方法返回的长度值是多少，如果没有足够的堆来满足请求，调用者可能会遇到 OutOfMemoryError。</li></ul><pre><code class="java">public static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;public static int newLength(int oldLength, int minGrowth, int prefGrowth) {    // preconditions not checked because of inlining    // assert oldLength &gt;= 0    // assert minGrowth &gt; 0    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow    if (0 &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) {        return prefLength;    } else {        // put code cold in a separate method        return hugeLength(oldLength, minGrowth);    }}private static int hugeLength(int oldLength, int minGrowth) {    int minLength = oldLength + minGrowth;    if (minLength &lt; 0) { // overflow        throw new OutOfMemoryError(            "Required array length " + oldLength + " + " + minGrowth + " is too large");    } else if (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) {        return SOFT_MAX_ARRAY_LENGTH;    } else {        return minLength;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> ArrayList </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包装类</title>
      <link href="/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/bg.jpg"></p><h1 id="包装类常量池"><a href="#包装类常量池" class="headerlink" title="包装类常量池"></a>包装类常量池</h1><p>Byte，Short，Integer，Long这4中包装类默认创建了数值[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean直接返回True or False。</p><h5 id="Integer缓存源码"><a href="#Integer缓存源码" class="headerlink" title="Integer缓存源码"></a>Integer缓存源码</h5><p>返回一个表示指定int值的Integer实例。如果不需要新的Integer实例，则通常应优先使用此方法而不是构造函数Integer(int) ，因为此方法可能会通过缓存频繁请求的值来显着提高空间和时间性能。此方法将始终缓存 -128 到 127（含）范围内的值，并且可能缓存此范围之外的其他值。</p><pre><code class="java">private static class IntegerCache {    static final int low = -128;    static final int high;    static final Integer cache[];    static {        // high value may be configured by property        int h = 127;        ......    }}public static Integer valueOf(int i) {    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}</code></pre><h5 id="Character缓存源码"><a href="#Character缓存源码" class="headerlink" title="Character缓存源码"></a>Character缓存源码</h5><p>返回表示指定char值的Character实例。如果不需要新的Character实例，则通常应优先使用此方法而不是构造函数Character(char) ，因为此方法可能会通过缓存频繁请求的值来显着提高空间和时间性能。此方法将始终缓存’\u0000’到’\u007F’范围内的值，包括在内，并且可能缓存此范围之外的其他值。</p><pre><code class="java">private static class CharacterCache {    private CharacterCache(){}    static final Character cache[] = new Character[127 + 1];    static {        for (int i = 0; i &lt; cache.length; i++)            cache[i] = new Character((char)i);        }    }}public static Character valueOf(char c) {    if (c &lt;= 127) { // must cache        return CharacterCache.cache[(int)c];    }    return new Character(c);}</code></pre><h5 id="Boolean缓存源码"><a href="#Boolean缓存源码" class="headerlink" title="Boolean缓存源码"></a>Boolean缓存源码</h5><p>返回一个表示指定boolean值的Boolean实例。如果指定的boolean值为true ，则此方法返回Boolean.TRUE ；如果为false ，则此方法返回Boolean.FALSE 。如果不需要新的Boolean实例，则通常应优先使用此方法而不是构造函数Boolean(boolean) ，因为此方法可能会产生明显更好的空间和时间性能。</p><pre><code class="java">public static Boolean valueOf(boolean b) {    return (b ? TRUE : FALSE);}</code></pre><h5 id="规范事项"><a href="#规范事项" class="headerlink" title="规范事项"></a>规范事项</h5><p><img src="/2022/06/17/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0/alibaba%E8%A7%84%E8%8C%83.png"></p><h5 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h5><ul><li><p>装箱：将基本类型用它们对应的引用类型包装起来</p></li><li><p>拆箱：将包装类型转换为基本数据类型</p><pre><code class="java">Integer i = 10;//装箱int n = i; //拆箱</code></pre><pre><code class="java"> 0 bipush 10 2 invokestatic #2 &lt;java/lang/Integer.valueOf : (I)Ljava/lang/Integer;&gt; 5 astore_1 6 aload_1 7 invokevirtual #3 &lt;java/lang/Integer.intValue : ()I&gt;10 istore_211 return</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 包装类 </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/bg.jpg"></p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="非分布式锁存在的问题及分布式锁原理"><a href="#非分布式锁存在的问题及分布式锁原理" class="headerlink" title="非分布式锁存在的问题及分布式锁原理"></a>非分布式锁存在的问题及分布式锁原理</h2><p>synchronized通过JVM内部的锁监视器只能保证内部多个线程之间的互斥，但在有多个JVM时，会存在多个锁监视器，就会导致多个线程获取到锁。如下图所示。</p><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E9%9D%9E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><p>为了解决上述问题，我们不能再使用JVM内部的锁监视器，而是让多个JVM使用同一个锁监视器。关键在于多进程可见及互斥。<br><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><h2 id="分布式锁定义及特性"><a href="#分布式锁定义及特性" class="headerlink" title="分布式锁定义及特性"></a>分布式锁定义及特性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>多进程可见</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ol><h2 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h2><ul><li>基于数据库<br>乐观锁：基于版本号<br>悲观锁：基于排它锁</li><li>基于Redis<br>setnx:获取锁时利用setnx的互斥特性，添加锁过期时间，避免服务宕机引起死锁；释放锁时手动释放(即删除)或超时释放。<br>Redlock机制</li><li>基于Zookeeper<br>临时有序节点:有序性实现互斥。多个线程在Zookeeper中创建节点，每个节点的ID单调递增，可以约定ID最小的获取锁成功。</li><li>基于Consul(不懂)</li></ul><table><thead><tr><th></th><th align="center">MySQl</th><th align="center">Redis</th><th align="center">Zookeeper</th></tr></thead><tbody><tr><td>互斥</td><td align="center">利用mysql本身的互斥锁机制</td><td align="center">利用setnx的互斥命令</td><td align="center">利用节点的唯一性和有序性实现互斥</td></tr><tr><td>高可用</td><td align="center">好</td><td align="center">好</td><td align="center">好</td></tr><tr><td>高性能</td><td align="center">一般</td><td align="center">好</td><td align="center">一般</td></tr><tr><td>安全性</td><td align="center">断开连接，自动释放锁</td><td align="center">利用锁超时时间，到期释放</td><td align="center">临时节点，断开连接自动释放</td></tr></tbody></table><h3 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h3><h4 id="1-方案一setnx"><a href="#1-方案一setnx" class="headerlink" title="1. 方案一setnx"></a>1. 方案一setnx</h4><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><ul><li><p>利用setnx获取锁，并设置过期时间，保存线程标识</p><pre><code># 添加锁，利用setnx的互斥特性SETNX lock thread1# 添加锁过期时间，避免服务宕机引起的死锁EXPIRE lock 10</code></pre></li><li><p>释放锁时先判断线程标识是否与自己一致，一致则删除锁</p><pre><code># 释放锁，删除即可DEL key</code></pre></li></ul><h5 id="代码实现及相关问题分析"><a href="#代码实现及相关问题分析" class="headerlink" title="代码实现及相关问题分析"></a>代码实现及相关问题分析</h5><h6 id="初版代码"><a href="#初版代码" class="headerlink" title="初版代码"></a>初版代码</h6><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/setnx.png" style="zoom:67%;"><pre><code class="java">public interface ILock {    /**     * 尝试获取锁     * @param timeoutSec     * @return     */    boolean tryLock(long timeoutSec);    /**     * 释放锁     */    void unlock();}</code></pre><pre><code class="java">import cn.hutool.core.lang.UUID;import org.springframework.core.io.ClassPathResource;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import java.util.Collections;import java.util.concurrent.TimeUnit;public class SimpleRedisLock implements ILock {    // 分布式锁的key    private String name;    private StringRedisTemplate stringRedisTemplate;    private static final String KEY_PREFIX = "lock:";    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {        this.name = name;        this.stringRedisTemplate = stringRedisTemplate;    }    @Override    public boolean tryLock(long timeoutSec) {        //获取线程标识        long threadId = Thread.currentThread().getId();        // 尝试获取锁        Boolean success = stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec,                                   TimeUnit.SECONDS);        return Boolean.TRUE.equals(success);    }        @Override    public void unlock() {        stringRedisTemplate.delete(KEY_PREFIX+name);    }}</code></pre><pre><code class="java">//调用SimpleRedisLock实现业务Long userId = UserHolder.getUser().getId();SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate);boolean isLock = lock.tryLock();// 判断是否获取锁if (!isLock) {    return Result.fail("不允许重复下单");}try {    //获取代理对象，涉及事务的失效问题    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();    return proxy.createVoucherOrder(voucherId);} finally {    lock.unlock();}</code></pre><h6 id="初版代码存在的问题分析"><a href="#初版代码存在的问题分析" class="headerlink" title="初版代码存在的问题分析"></a>初版代码存在的问题分析</h6><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%9D%E7%BA%A7%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81problem.png"></p><p>​        如上图所示，红线表示Redis锁的持有周期，线程1在执行过程中首先尝试获取锁。获取成功后线程1开始执行业务逻辑，此时若发生阻塞则会导致线程1持有锁的时间变长。这时可能出现两种情况：(1)线程1执行完业务后自己释放；(2)线程1阻塞时间超过超时时间，触发超时释放。<br>​        由于线程1持有的锁超时释放，其他线程如线程2就可以成功获取锁并开始执行自己的业务。若此时线程1被唤醒且业务完成，则需要进行释放锁，即直接删除锁。但此时释放的锁为线程2持有的锁。若线程3此时获取锁，则能够获取成功并执行相应的业务，就会导致并行执行的问题。</p><h6 id="初版代码问题解决方案"><a href="#初版代码问题解决方案" class="headerlink" title="初版代码问题解决方案"></a>初版代码问题解决方案</h6><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%9D%E7%BA%A7%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></p><p>如上图所示，在触发超时释放锁后，当前线程业务完成后释放锁时需要判断存入redis的线程标识是否与当前线程ID一致，不一致则不释放锁，一致则释放锁。流程图如下。</p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/second-version.png" style="zoom:67%;"><h6 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h6><p>在SimpleRedisLock中添加修改为下面代码</p><pre><code class="java">private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";//添加该行代码// 修改tryLock逻辑如下@Overridepublic boolean tryLock(long timeoutSec) {    //获取线程标识    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 尝试获取锁    Boolean success = stringRedisTemplate.opsForValue()        .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);}//修改unlock逻辑如下@Overridepublic void unlock() {    //获取线程标识    String threadId = ID_PREFIX + Thread.currentThread().getId();    //获取锁的线程标识    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);    //判断是否是自己的锁    if (threadId.equals(id)) {        stringRedisTemplate.delete(KEY_PREFIX + name);    }}</code></pre><h6 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h6><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98.png"><br>如上图所示，线程1首先申请获取锁并开始执行业务，业务执行完成后获取锁标识并判断是否一致。由于判断与释放并不具有原子性，因此如果判断完成后且未释放锁之前发生了阻塞，如JVM的FullGC，可能会导致锁的超时释放，线程2就可以成功获取到锁并执行业务。若此时阻塞结束，线程1恢复运行，由于判断已经执行完成且认定为现存的锁为自身持有的锁，则又一次会删除线程2持有的锁。根据初版代码的问题则可能会出现并行执行的问题。</p><h6 id="Lua脚本解决原子性问题"><a href="#Lua脚本解决原子性问题" class="headerlink" title="Lua脚本解决原子性问题"></a>Lua脚本解决原子性问题</h6><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行的原子性。基本语法：<a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a><br>Redis提供的调用函数语法如下：</p><pre><code class="lua"># 执行redis命令redis.call('命令名称', 'key', '其它参数', ...)</code></pre><p>执行脚本语法如下:<br><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/eval.png"></p><p>Redis提供执行脚本的方法</p><pre><code class="java">public &lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) {        return this.scriptExecutor.execute(script, keys, args);}</code></pre><p>释放锁的业务流程如下：</p><ol><li>获取锁中的线程标识</li><li>判断是否与指定的标识(当前线程标识)一致</li><li>如果一致则释放锁(即删除锁)</li><li>如果不一致则什么都不做</li></ol><p>在resources目录下创建unlock.lua脚本</p><pre><code class="lua">--比较线程标识与锁中的标识是否一致if(redis.call('get',KEYS[1]) == ARGV[1]) then    --释放锁 del key    return redis.call('del',KEYS[1])endreturn 0</code></pre><p>SimpleRedisLock.java文件中进行如下添加修改</p><pre><code class="java">private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;//添加该行代码//添加如下静态代码块加载lua脚本static {        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));        UNLOCK_SCRIPT.setResultType(Long.class);    }//修改unlock逻辑@Overridepublic void unlock() {    //调用lua脚本    stringRedisTemplate.execute(        UNLOCK_SCRIPT,        Collections.singletonList(KEY_PREFIX + name),        ID_PREFIX + Thread.currentThread().getId());}</code></pre><h6 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h6><ul><li>利用setnx满足互斥性</li><li>利用setex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用redis集群保证高可用和高并发</li></ul><h6 id="基于setnx实现的分布式锁存在的问题"><a href="#基于setnx实现的分布式锁存在的问题" class="headerlink" title="基于setnx实现的分布式锁存在的问题"></a>基于setnx实现的分布式锁存在的问题</h6><ul><li>不可重入：同一个线程无法多次获取同一把锁</li><li>不可重试：获取锁只尝试一次就返回false，没有重试机制</li><li>超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li><li>主从一致性：如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现</li></ul><h2 id="Redisson原理"><a href="#Redisson原理" class="headerlink" title="Redisson原理"></a>Redisson原理</h2><p>官方地址：<a href="https://redisson.org/">https://redisson.org</a><br>GitHub地址：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><h3 id="Redisson分布式锁优化"><a href="#Redisson分布式锁优化" class="headerlink" title="Redisson分布式锁优化"></a>Redisson分布式锁优化</h3><ul><li><p>引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.17.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置Redisson客户端</p><p>注意导入的是redisson下的Config包</p><pre><code class="java">import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RedissonConfig {    @Bean    public RedissonClient redissonClient(){        Config config = new Config();        config.useSingleServer().setAddress("redis://192.168.139.128:6379").setPassword("20010604");        return Redisson.create(config);    }}</code></pre></li></ul><h4 id="不可重入问题-Redisson可重入锁原理"><a href="#不可重入问题-Redisson可重入锁原理" class="headerlink" title="不可重入问题(Redisson可重入锁原理)"></a>不可重入问题(Redisson可重入锁原理)</h4><p>Redisson可重入锁，是基于redis的Hash类型实现的，分别有三个参数：key、field、value。其中key还是和原来我们自定义的string类型分布式锁一样，就是前面的锁key，类似于lock:order:userId这种；而field就是原来我们自定义的string类型分布式锁的value，类似于(UUID + 线程id)的组合；而Hash类型中的value，就是该锁的重入数量。<br>根据可重入锁的原理可知，为了保证原子性和一致性，以上的操作必须使用Lua脚本来实现。</p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redisson可重入锁原理.png" style="zoom:80%;"><h4 id="Redisson分布式锁原理"><a href="#Redisson分布式锁原理" class="headerlink" title="Redisson分布式锁原理"></a>Redisson分布式锁原理</h4><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png"></p><ul><li>可重入：利用hash结构记录线程id和重入次数</li><li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制。因为采用了订阅发布功能，所以线程在获取锁失败以后的重试并不是一直尝试，而是先睡眠，等待释放锁的信号以后再被唤醒去尝试获取锁，这样很好的做到了不浪费CPU性能。</li><li>超时续约：利用watchDog，每隔一段时间（releaseTime / 3），重置超时时间。利用watchDog只有在未显式指定加锁时间（leaseTime）时才会生效。（这点很重要）若显式指定leaseTime参数，则看门狗会失效，不会自动为超时key续约。所以当我们不指定Redisson的tryLock()里的leaseTime时，那么这个锁只有在业务结束之后线程主动释放可以被释放，并不会因为线程业务阻塞而导致锁超时被释放，被其他线程获取到锁从而导致线程不安全问题。当时我们显式指定leaseTime时，WatchDog就不会生效，就会出现超时释放的情况，所以这一切都视情况来使用。</li></ul><h4 id="Redisson分布式锁主从一致性问题"><a href="#Redisson分布式锁主从一致性问题" class="headerlink" title="Redisson分布式锁主从一致性问题"></a>Redisson分布式锁主从一致性问题</h4><p>Redisson对redis集群主从一致性问题的解决方案就是采用联锁。联锁（RedissonMultiLock）对象可以将多个RLock对象关联为一个联锁，实现加锁和解锁功能。每个RLock对象实例可以来自于不同的Redi<br>sson实例。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>不可重入Redis分布式锁 </p><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</p><p>缺陷：不可重入、无法重试、锁超时失效</p></li><li><p>可重入的Redis分布式锁</p><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待    </p><p>缺陷：redis宕机引起锁失效问题</p></li><li><p>Redisson的multiLock(联锁，主从一致性解决方案)</p><p>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</p><p>缺陷：运维成本高、实现复杂</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redisson </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务失效问题</title>
      <link href="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/error.jpg"></p><h2 id="Spring中事务失效的情况"><a href="#Spring中事务失效的情况" class="headerlink" title="Spring中事务失效的情况"></a>Spring中事务失效的情况</h2><p>官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction">Data Access (spring.io)</a></p><h4 id="1-方法可见性和-Transactional-Method-visibility-and-Transactional"><a href="#1-方法可见性和-Transactional-Method-visibility-and-Transactional" class="headerlink" title="1.方法可见性和@Transactional  (Method visibility and @Transactional)"></a>1.方法可见性和@Transactional  (Method visibility and @Transactional)</h4><p>When you use transactional proxies with Spring’s standard configuration, you should apply the annotation only to methods with visibility. If you do annotate , , or package-visible methods with the annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.<br>当您将事务代理与Spring的标准配置一起使用时，您应该仅将注解应用于具有可见性的方法(public方法)。如果您？？？(不会翻译)或对包可见方法使用注解，则不会引发任何错误，但带注解的方法不会显示配置的事务设置。</p><h5 id="遇到的相关问题"><a href="#遇到的相关问题" class="headerlink" title="遇到的相关问题"></a>遇到的相关问题</h5><p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/errorSource.png"></p><p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/errorInfo.png"></p><p>private修饰的方法，spring无法生成动态代理。AOP代理分别在intercept()和invoke()方法判断是否进行事务拦截，这两个方法都会间接调用AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法来获取事务控制的相关属性。(作者：爪哇驿站 链接：<a href="https://www.zhihu.com/question/334666648/answer/2250122133">https://www.zhihu.com/question/334666648/answer/2250122133</a>)</p><pre><code class="java">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {        if (this.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {            return null;        } else {            ...        }}</code></pre><p>上述代码会导致no-public方法无法进入事务控制。</p><h4 id="2-方法内部调用"><a href="#2-方法内部调用" class="headerlink" title="2.方法内部调用"></a>2.方法内部调用</h4><p> In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with . Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code — for example, in a method.<br>在代理模式(这是默认设置)中，仅拦截通过代理传入的外部方法调用。这意味着自调用(实际上，目标对象内的方法调用目标对象的另一个方法)在运行时不会导致实际的事务生效即使调用的方法被标记。此外，代理必须完全初始化才能提供预期的行为，因此不应在初始化代码(例如，在方法中)依赖此功能。</p><h5 id="遇到的相关问题-1"><a href="#遇到的相关问题-1" class="headerlink" title="遇到的相关问题"></a>遇到的相关问题</h5><pre><code class="java">@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService {    @Override    public Result seckillVoucher(Long voucherId) {        ...        Long userId = UserHolder.getUser().getId();        synchronized (userId.toString().intern()) {            //获取代理对象，涉及事务的失效问题            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        }    }        @Transactional    public Result createVoucherOrder(Long voucherId) {        ...    }}</code></pre><p>如上述代码所示只对createVoucherOrder()加了注解，在seckillVoucher()中直接调用createVoucherOrder()时，实际是通过this.createVoucher()调用的，目标对象是没有事务功能的。这里需要通过AopContext.currentProxy()方法获取当前对象的代理对象，再通过代理对象调用createVoucherOrder()方法。</p><p>相关配置如下:<br>pom.xml文件中导入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>项目启动类添加@EnableAspectJAutoProxy(exposeProxy = true)</p><pre><code class="java">@EnableAspectJAutoProxy(exposeProxy = true)@MapperScan("com.hmdp.mapper")@SpringBootApplicationpublic class HmDianPingApplication {    public static void main(String[] args) {        SpringApplication.run(HmDianPingApplication.class, args);    }}</code></pre><h4 id="微服务中出现的事务失效问题"><a href="#微服务中出现的事务失效问题" class="headerlink" title="微服务中出现的事务失效问题"></a>微服务中出现的事务失效问题</h4><p>该部分业务涉及到的表包括pms_spu_info(spu基本信息)、pms_spu_info_desc(spu图片信息)、pms_spu_images(spu图片集合)、pms_product_attr_value(spu规格参数)、sms_spu_bounds(积分信息)、pms_sku_info(sku基本信息)、pms_sku_images(sku图片信息)、pms_sku_sale_attr_value(sku销售属性信息)、sms_sku_ladder\sms_sku_full_reduction\sms_member_price(sku的优惠、满减等信息)。<br>由于该业务涉及到其他微服务模块的功能，需要通过CouponFeignService接口进行相关功能的调用。为了保证该业务功能的原子性，为整个方法加上了<code>@Transactional</code>注解。</p><p><code>saveSpuInfo(SpuSaveVo vo)</code></p><pre><code class="java">@Transactional@Overridepublic void saveSpuInfo(SpuSaveVo vo) {    ......    couponFeignService.saveSpuBounds(spuBoundTo);    ......    couponFeignService.saveSkuReduction(skuReductionTo);}</code></pre><p><code>CouponFeignService</code></p><pre><code class="java">@FeignClient("coupon")public interface CouponFeignService {    @PostMapping("/coupon/spubounds/save")    R saveSpuBounds(@RequestBody SpuBoundTo spuBoundTo);    @PostMapping("/coupon/skufullreduction/saveinfo")    R saveSkuReduction(@RequestBody SkuReductionTo skuReductionTo);}</code></pre><p>问题重现：</p><p>将接口<code>CouponFeignService</code>中的第二个方法即<code>saveSkuReducation()</code>的请求路径与<code>CouponController</code>类中该方法的请求路径保持不一致。通过前端项目(Postman等工具)发送请求信息，由于远程调用接口的请求路径不一致导致该业务出现异常，无法远程调用该方法，因此数据库应该进行回滚操作。此时查看数据库，发现spu_bounds表中的数据并没有发生回滚，而是被插入到数据库并保存下来。<br>相关问题issue <a href="https://github.com/codingapi/tx-lcn/issues/340">feign远程调用，事务回滚不生效 · Issue #340 · codingapi/tx-lcn (github.com)</a></p><p>问题分析：</p><p><a href="https://so.csdn.net/so/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;spm=1001.2101.3001.7020">微服务</a>中，某事务内通过feign调用多个api，但Transcational注解的事务只对本服务的流程有效，他们并不在一次事务中，feign调用的接口不会回滚。</p><p>解决方案：</p><p>对于异常回滚，异常可以传递给服务提供方，服务提供方再通过异常回滚。</p><p>分布式事务seata(待学习)</p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Data Access </category>
          
          <category> Transaction Management </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git初体验</title>
      <link href="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/gitpng.png" alt="cover"></p><h2 id="一、git-2-36-1安装"><a href="#一、git-2-36-1安装" class="headerlink" title="一、git 2.36.1安装"></a>一、git 2.36.1安装</h2><h3 id="1-1-git下载"><a href="#1-1-git下载" class="headerlink" title="1.1 git下载"></a>1.1 git下载</h3><p>官方链接：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a><br>个人下载的版本：git-2.36.1<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/git-2.36.1.jpg"></p><h3 id="1-2-git安装"><a href="#1-2-git安装" class="headerlink" title="1.2 git安装"></a>1.2 git安装</h3><h4 id="1-2-1使用许可声明"><a href="#1-2-1使用许可声明" class="headerlink" title="1.2.1使用许可声明"></a>1.2.1使用许可声明</h4><p>双击Git-2.36.1-64-bit.exe，开始安装，该页面显示第二版协议内容。<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/license.png"></p><h4 id="1-2-2-选择安装目录"><a href="#1-2-2-选择安装目录" class="headerlink" title="1.2.2 选择安装目录"></a>1.2.2 选择安装目录</h4><p>选择安装git的目录(因为装过一遍，这一步的图没了)。</p><h4 id="1-2-3-选择安装组件"><a href="#1-2-3-选择安装组件" class="headerlink" title="1.2.3 选择安装组件"></a>1.2.3 选择安装组件</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/components.png"><br>Additional icons:添加桌面图标<br>Windows Explorer integration:添加功能到鼠标右键菜单</p><ul><li>Git Bash Here:命令行模式<ul><li>Git GUI Here:图形界面</li></ul></li></ul><p>Git LFS(Large File Support):大文件支持<br>Check daily for Git for Windows updates:日常检查Git是否有更新<br>Add a Git Bash Profile to Windows Terminal:将Git Bash配置文件添加到Windows终端</p><h4 id="1-2-4-选择git默认编辑器"><a href="#1-2-4-选择git默认编辑器" class="headerlink" title="1.2.4 选择git默认编辑器"></a>1.2.4 选择git默认编辑器</h4><p>git安装程序内置提供了Vim、Notepad++、Visual Studio Code、Sublime、Notepad、Atom等编辑器。个人选择Vim编辑器。</p><h4 id="1-2-5-选择初始化新仓库的主干名字"><a href="#1-2-5-选择初始化新仓库的主干名字" class="headerlink" title="1.2.5 选择初始化新仓库的主干名字"></a>1.2.5 选择初始化新仓库的主干名字</h4><ul><li>Let Git decide:由Git自己选择，目前为”master”</li><li>很多团队已经重命名他们的默认主干为”main”，具体原因可参考<a href="https://pages.carm.cc/doc/branch-main.html">为什么Git分支开始从“master”变为“main”了？ (carm.cc)</a><br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/branch.png"></li></ul><h4 id="1-2-6-调整path环境变量"><a href="#1-2-6-调整path环境变量" class="headerlink" title="1.2.6 调整path环境变量"></a>1.2.6 调整path环境变量</h4><ul><li><p>Use Git from Git Bash only</p><p>这是最谨慎的选择，因为您的PATH根本不会被修改。你只能在Git Bash中使用Git命令行工具。</p></li><li><p>Git from the command line and also from 3rd-party software</p><p>(推荐)此选项只向您的path添加一些最小的Git包装器，以避免使用可选的Unix工具打乱您的环境。</p><p>你将能够使用Git从Git Bash，命令提示符和windowvpowershell以及任何第三方软件寻找Git在PATH。</p></li><li><p>use Git and optional Unix tools from the Command Prompt</p><p>Git和可选的Unix工具都将被添加到你的PATH中。警告:这将覆盖Windows工具，如“查找”和“排序”。如果您了解其中的含义，请仅使用此选项。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/PathEnvironment.png"></p></li></ul><h4 id="1-2-7-选择SSH执行文件"><a href="#1-2-7-选择SSH执行文件" class="headerlink" title="1.2.7 选择SSH执行文件"></a>1.2.7 选择SSH执行文件</h4><ul><li><p>Use bundled openSSH<br>这使用了Git附带的ssh.exe。</p></li><li><p>Use external OpenSSH</p><p>这将使用外部ssh.exe。Git不会生成自己的OpenSSH。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/SSH.png"></p></li></ul><h4 id="1-2-8-选择HTTPS后端传输"><a href="#1-2-8-选择HTTPS后端传输" class="headerlink" title="1.2.8 选择HTTPS后端传输"></a>1.2.8 选择HTTPS后端传输</h4><ul><li><p>use the openSSL library</p><p>服务器证书将使用ca-bundle.crt文件进行验证。</p></li><li><p>use the native Windows secure Channel library</p><p>将使用Windows证书存储来验证服务器证书。这个选项也允许你使用你公司的内部根CA证书，例如通过Active Directory域服务分发。</p></li></ul><h5 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h5><p>链接：<a href="https://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr">git - OpenSSL 和本机 Windows 安全通道库有什么区别 - 堆栈溢出 (stackoverflow.com)</a></p><p>如果在具有企业托管证书的组织中使用 git，则需要使用安全通道。如果您仅使用 git 访问公共存储库（如 GitHub），或者您的组织不管理自己的证书，那么使用 SSL 后端（它们只是同一协议的不同实现）都可以。<br>从 <a href="https://github.com/git/git/commit/21084e84a418e0a6c4da72f632c5cd99386bd64b">https://github.com/git/git/commit/21084e84a418e0a6c4da72f632c5cd99386bd64b</a></p><pre><code>从版本 7.56.0 开始，curl 支持使用多个 SSL 后端进行编译。此修补程序添加了该功能的 Git 端：通过将 http.sslBackend 设置为“openssl”或“schannel”，Git for Windows 现在可以在运行时选择 SSL 后端。这在 Windows 上派上用场，因为安全通道（“schannel”）是访问 Windows 凭据存储的本机解决方案，从而允许企业范围的证书管理。由于历史原因，Git for Windows仍然需要支持OpenSSL，因为它以前是Git for Windows中唯一支持的SSL后端近十年了。该补丁已经在Git for Windows中进行了一年多，并且被认为是成熟的。</code></pre><h4 id="1-2-9-配置行尾符号转换"><a href="#1-2-9-配置行尾符号转换" class="headerlink" title="1.2.9 配置行尾符号转换"></a>1.2.9 配置行尾符号转换</h4><ul><li><p>Checkout Windows-style,commit Unix-style line endings</p><p>Git在检出文本文件时会将LF转换为CRLF。在提交文本文件时，会将CRLF转换为LT。对于跨平台的项目，这是Windows上的推荐设置(“core.autocrlf”设置为“true”)。</p></li><li><p>Checkout as-is,commit Unix-style line endings</p><p>当签出文本文件时，Git不会执行任何转换。提交文本文件时，CRLF将被转换为LF。对于跨平台项目，这是Unix上的推荐设置(“core.autocrlf”设置为“input”)。</p></li><li><p>Checkout as-is,commit as-is</p><p>当签出或提交文本文件时，Git不会执行任何转换。对于跨平台项目，不建议选择此选项(“core.autocrlf”设置为“false”)。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/line-ending.png"></p></li></ul><h4 id="1-2-10-配置终端模拟器以与-Git-Bash一起使用"><a href="#1-2-10-配置终端模拟器以与-Git-Bash一起使用" class="headerlink" title="1.2.10 配置终端模拟器以与 Git Bash一起使用"></a>1.2.10 配置终端模拟器以与 Git Bash一起使用</h4><ul><li><p>Use MinTTY (the default terminal of MSYS2)</p><p>Git Bash将使用MinTTY作为终端模拟器，它具有一个可调整大小的窗口非矩形选择和Unicode字体。Windows控制台程序(suc作为交互式Python)必须通过winpty启动才能在MinTTY工作。</p></li><li><p>Use Windows’default console window</p><p>Git将使用Windows的默认控制台窗口(“cmd.exe”)与Win32控制台程序，如交互式Python或node.js，但有一个非常有限的默认回滚，需要配置为使用Unicode字体以正确显示非ascii字符，并且在Windows 10之前为其窗口不能自由地调整大小，它只允许矩形文本选择。<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/terminalAndBash.png"></p></li></ul><h4 id="1-2-11-选择默认的”git-pull”行为-默认即可"><a href="#1-2-11-选择默认的”git-pull”行为-默认即可" class="headerlink" title="1.2.11 选择默认的”git pull”行为(默认即可)"></a>1.2.11 选择默认的”git pull”行为(默认即可)</h4><ul><li><p>Default (fast-forward or merge)</p><p>这是git pull的标准行为:在可能的情况下，将当前分支快进到获取的分支，否则创建一个merge commit。</p></li><li><p>Rebase</p><p>将当前分支重新基于获取的分支。如果没有对rebase的本地提交，这相当于快进。</p></li><li><p>Only ever fast-forward</p><p>快进到获取的分支。如果不可能，就失败。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/git_pull.png"></p></li></ul><h4 id="1-2-12-选择一个凭证助手"><a href="#1-2-12-选择一个凭证助手" class="headerlink" title="1.2.12 选择一个凭证助手"></a>1.2.12 选择一个凭证助手</h4><ul><li><p>Git Credential Manager</p><p>使用跨平台的Git Credential Manager。<br>在这里查看Git凭据管理器未来的更多信息。</p></li><li><p>None</p><p>不要使用凭据助手。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/credentialHelper.png"></p></li></ul><p>Git Credential Manager提供登录凭证帮助，Git 有时需要用户的凭据才能执行操作；例如，可能需要输入用户名和密码才能通过 HTTP 访问远程存储库。</p><h4 id="1-2-13-配置额外选项"><a href="#1-2-13-配置额外选项" class="headerlink" title="1.2.13 配置额外选项"></a>1.2.13 配置额外选项</h4><ul><li><p>Enable file system caching</p><p>对于某些操作，文件系统数据将被批量读取并缓存在内存中(“core.fscache”设置为“true”)。这提供了显著的性能提升。</p></li><li><p>Enable symbolic links</p><p>启用符号链接(需要SeCreateSymbolicLink权限)。 请注意，现有的存储库不受此设置的影响。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/extra_options.png"></p></li></ul><h4 id="1-2-14-配置实验性选项"><a href="#1-2-14-配置实验性选项" class="headerlink" title="1.2.14 配置实验性选项"></a>1.2.14 配置实验性选项</h4><ul><li><p>Enable experimental support for pseudo consoles.</p><p>这允许在Git Bash窗口中运行本机控制台程序，如Node或Python，而无需使用winpty，但它仍有已知的缺陷。</p></li><li><p>Enable experimental built-in file system monitor</p><p>自动运行内置的文件系统监视器，以加速包含许多文件的工作树中的常见操作，如git status ‘、git add ‘、git commit ‘等。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/experimental_options.png"></p></li></ul><h3 id="二、idea安装git"><a href="#二、idea安装git" class="headerlink" title="二、idea安装git"></a>二、idea安装git</h3><h4 id="2-1-打开IDEA，选择File-settings-Version-Control-Git"><a href="#2-1-打开IDEA，选择File-settings-Version-Control-Git" class="headerlink" title="2.1 打开IDEA，选择File-settings-Version Control-Git"></a>2.1 打开IDEA，选择File-settings-Version Control-Git</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.1.png"></p><h4 id="2-2-Path-to-Git-executable右侧选择文件夹标志-Browse…-Shift-Enter-选择Git安装目录下bin-git-exe"><a href="#2-2-Path-to-Git-executable右侧选择文件夹标志-Browse…-Shift-Enter-选择Git安装目录下bin-git-exe" class="headerlink" title="2.2 Path to Git executable右侧选择文件夹标志(Browse…(Shift+Enter)),选择Git安装目录下bin-git.exe"></a>2.2 Path to Git executable右侧选择文件夹标志(Browse…(Shift+Enter)),选择Git安装目录下bin-git.exe</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.2.png"></p><h4 id="2-3-Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set-this-path-only-for-the-current-project下显示版本信息。"><a href="#2-3-Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set-this-path-only-for-the-current-project下显示版本信息。" class="headerlink" title="2.3 Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set this path only for the current project下显示版本信息。"></a>2.3 Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set this path only for the current project下显示版本信息。</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.3.png"></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/mukes/article/details/115693833">(25条消息) Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/23/hello-world/"/>
      <url>/2022/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
