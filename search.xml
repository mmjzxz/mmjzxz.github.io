<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式锁</title>
      <link href="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/bg.jpg"></p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="非分布式锁存在的问题及分布式锁原理"><a href="#非分布式锁存在的问题及分布式锁原理" class="headerlink" title="非分布式锁存在的问题及分布式锁原理"></a>非分布式锁存在的问题及分布式锁原理</h2><p>synchronized通过JVM内部的锁监视器只能保证内部多个线程之间的互斥，但在有多个JVM时，会存在多个锁监视器，就会导致多个线程获取到锁。如下图所示。</p><p><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E9%9D%9E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><p>为了解决上述问题，我们不能再使用JVM内部的锁监视器，而是让多个JVM使用同一个锁监视器。关键在于多进程可见及互斥。<br><img src="/2022/05/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><h2 id="分布式锁定义及实现"><a href="#分布式锁定义及实现" class="headerlink" title="分布式锁定义及实现"></a>分布式锁定义及实现</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><h4 id="需要具有的特性"><a href="#需要具有的特性" class="headerlink" title="需要具有的特性"></a>需要具有的特性</h4><ol><li>多进程可见</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ol><h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><h2 id="Redisson原理"><a href="#Redisson原理" class="headerlink" title="Redisson原理"></a>Redisson原理</h2><p>官方地址：<a href="https://redisson.org/">https://redisson.org</a><br>GitHub地址：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><h3 id="Redisson分布式锁优化"><a href="#Redisson分布式锁优化" class="headerlink" title="Redisson分布式锁优化"></a>Redisson分布式锁优化</h3><ul><li><p>引入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.17.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置Redisson客户端</p><p>注意导入的是redisson下的Config包</p><pre><code class="java">import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RedissonConfig {    @Bean    public RedissonClient redissonClient(){        Config config = new Config();        config.useSingleServer().setAddress("redis://192.168.139.128:6379").setPassword("20010604");        return Redisson.create(config);    }}</code></pre></li></ul><h4 id="不可重入问题"><a href="#不可重入问题" class="headerlink" title="不可重入问题"></a>不可重入问题</h4>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redisson </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务失效问题</title>
      <link href="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/error.jpg"></p><h2 id="Spring中事务失效的情况"><a href="#Spring中事务失效的情况" class="headerlink" title="Spring中事务失效的情况"></a>Spring中事务失效的情况</h2><p>官方文档：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction">Data Access (spring.io)</a></p><h4 id="1-方法可见性和-Transactional-Method-visibility-and-Transactional"><a href="#1-方法可见性和-Transactional-Method-visibility-and-Transactional" class="headerlink" title="1.方法可见性和@Transactional  (Method visibility and @Transactional)"></a>1.方法可见性和@Transactional  (Method visibility and @Transactional)</h4><p>When you use transactional proxies with Spring’s standard configuration, you should apply the annotation only to methods with visibility. If you do annotate , , or package-visible methods with the annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.<br>当您将事务代理与Spring的标准配置一起使用时，您应该仅将注解应用于具有可见性的方法(public方法)。如果您？？？(不会翻译)或对包可见方法使用注解，则不会引发任何错误，但带注解的方法不会显示配置的事务设置。</p><h5 id="遇到的相关问题"><a href="#遇到的相关问题" class="headerlink" title="遇到的相关问题"></a>遇到的相关问题</h5><p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/errorSource.png"></p><p><img src="/2022/05/24/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/errorInfo.png"></p><p>private修饰的方法，spring无法生成动态代理。AOP代理分别在intercept()和invoke()方法判断是否进行事务拦截，这两个方法都会间接调用AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法来获取事务控制的相关属性。(作者：爪哇驿站 链接：<a href="https://www.zhihu.com/question/334666648/answer/2250122133">https://www.zhihu.com/question/334666648/answer/2250122133</a>)</p><pre><code class="java">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {        if (this.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {            return null;        } else {            ...        }}</code></pre><p>上述代码会导致no-public方法无法进入事务控制。</p><h4 id="2-方法内部调用"><a href="#2-方法内部调用" class="headerlink" title="2.方法内部调用"></a>2.方法内部调用</h4><p> In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with . Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code — for example, in a method.<br>在代理模式(这是默认设置)中，仅拦截通过代理传入的外部方法调用。这意味着自调用(实际上，目标对象内的方法调用目标对象的另一个方法)在运行时不会导致实际的事务生效即使调用的方法被标记。此外，代理必须完全初始化才能提供预期的行为，因此不应在初始化代码(例如，在方法中)依赖此功能。</p><h5 id="遇到的相关问题-1"><a href="#遇到的相关问题-1" class="headerlink" title="遇到的相关问题"></a>遇到的相关问题</h5><pre><code class="java">@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService {    @Override    public Result seckillVoucher(Long voucherId) {        ...        Long userId = UserHolder.getUser().getId();        synchronized (userId.toString().intern()) {            //获取代理对象，涉及事务的失效问题            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        }    }        @Transactional    public Result createVoucherOrder(Long voucherId) {        ...    }}</code></pre><p>如上述代码所示只对createVoucherOrder()加了注解，在seckillVoucher()中直接调用createVoucherOrder()时，实际是通过this.createVoucher()调用的，目标对象是没有事务功能的。这里需要通过AopContext.currentProxy()方法获取当前对象的代理对象，再通过代理对象调用createVoucherOrder()方法。</p><p>相关配置如下:<br>pom.xml文件中导入依赖</p><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>项目启动类添加@EnableAspectJAutoProxy(exposeProxy = true)</p><pre><code class="java">@EnableAspectJAutoProxy(exposeProxy = true)@MapperScan("com.hmdp.mapper")@SpringBootApplicationpublic class HmDianPingApplication {    public static void main(String[] args) {        SpringApplication.run(HmDianPingApplication.class, args);    }}</code></pre><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> Data Access </category>
          
          <category> Transaction Management </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git初体验</title>
      <link href="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/gitpng.png" alt="cover"></p><h2 id="一、git-2-36-1安装"><a href="#一、git-2-36-1安装" class="headerlink" title="一、git 2.36.1安装"></a>一、git 2.36.1安装</h2><h3 id="1-1-git下载"><a href="#1-1-git下载" class="headerlink" title="1.1 git下载"></a>1.1 git下载</h3><p>官方链接：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a><br>个人下载的版本：git-2.36.1<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/git-2.36.1.jpg"></p><h3 id="1-2-git安装"><a href="#1-2-git安装" class="headerlink" title="1.2 git安装"></a>1.2 git安装</h3><h4 id="1-2-1使用许可声明"><a href="#1-2-1使用许可声明" class="headerlink" title="1.2.1使用许可声明"></a>1.2.1使用许可声明</h4><p>双击Git-2.36.1-64-bit.exe，开始安装，该页面显示第二版协议内容。<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/license.png"></p><h4 id="1-2-2-选择安装目录"><a href="#1-2-2-选择安装目录" class="headerlink" title="1.2.2 选择安装目录"></a>1.2.2 选择安装目录</h4><p>选择安装git的目录(因为装过一遍，这一步的图没了)。</p><h4 id="1-2-3-选择安装组件"><a href="#1-2-3-选择安装组件" class="headerlink" title="1.2.3 选择安装组件"></a>1.2.3 选择安装组件</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/components.png"><br>Additional icons:添加桌面图标<br>Windows Explorer integration:添加功能到鼠标右键菜单</p><ul><li>Git Bash Here:命令行模式<ul><li>Git GUI Here:图形界面</li></ul></li></ul><p>Git LFS(Large File Support):大文件支持<br>Check daily for Git for Windows updates:日常检查Git是否有更新<br>Add a Git Bash Profile to Windows Terminal:将Git Bash配置文件添加到Windows终端</p><h4 id="1-2-4-选择git默认编辑器"><a href="#1-2-4-选择git默认编辑器" class="headerlink" title="1.2.4 选择git默认编辑器"></a>1.2.4 选择git默认编辑器</h4><p>git安装程序内置提供了Vim、Notepad++、Visual Studio Code、Sublime、Notepad、Atom等编辑器。个人选择Vim编辑器。</p><h4 id="1-2-5-选择初始化新仓库的主干名字"><a href="#1-2-5-选择初始化新仓库的主干名字" class="headerlink" title="1.2.5 选择初始化新仓库的主干名字"></a>1.2.5 选择初始化新仓库的主干名字</h4><ul><li>Let Git decide:由Git自己选择，目前为”master”</li><li>很多团队已经重命名他们的默认主干为”main”，具体原因可参考<a href="https://pages.carm.cc/doc/branch-main.html">为什么Git分支开始从“master”变为“main”了？ (carm.cc)</a><br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/branch.png"></li></ul><h4 id="1-2-6-调整path环境变量"><a href="#1-2-6-调整path环境变量" class="headerlink" title="1.2.6 调整path环境变量"></a>1.2.6 调整path环境变量</h4><ul><li><p>Use Git from Git Bash only</p><p>这是最谨慎的选择，因为您的PATH根本不会被修改。你只能在Git Bash中使用Git命令行工具。</p></li><li><p>Git from the command line and also from 3rd-party software</p><p>(推荐)此选项只向您的path添加一些最小的Git包装器，以避免使用可选的Unix工具打乱您的环境。</p><p>你将能够使用Git从Git Bash，命令提示符和windowvpowershell以及任何第三方软件寻找Git在PATH。</p></li><li><p>use Git and optional Unix tools from the Command Prompt</p><p>Git和可选的Unix工具都将被添加到你的PATH中。警告:这将覆盖Windows工具，如“查找”和“排序”。如果您了解其中的含义，请仅使用此选项。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/PathEnvironment.png"></p></li></ul><h4 id="1-2-7-选择SSH执行文件"><a href="#1-2-7-选择SSH执行文件" class="headerlink" title="1.2.7 选择SSH执行文件"></a>1.2.7 选择SSH执行文件</h4><ul><li><p>Use bundled openSSH<br>这使用了Git附带的ssh.exe。</p></li><li><p>Use external OpenSSH</p><p>这将使用外部ssh.exe。Git不会生成自己的OpenSSH。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/SSH.png"></p></li></ul><h4 id="1-2-8-选择HTTPS后端传输"><a href="#1-2-8-选择HTTPS后端传输" class="headerlink" title="1.2.8 选择HTTPS后端传输"></a>1.2.8 选择HTTPS后端传输</h4><ul><li><p>use the openSSL library</p><p>服务器证书将使用ca-bundle.crt文件进行验证。</p></li><li><p>use the native Windows secure Channel library</p><p>将使用Windows证书存储来验证服务器证书。这个选项也允许你使用你公司的内部根CA证书，例如通过Active Directory域服务分发。</p></li></ul><h5 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h5><p>链接：<a href="https://stackoverflow.com/questions/62456484/whats-the-difference-between-openssl-and-the-native-windows-secure-channel-libr">git - OpenSSL 和本机 Windows 安全通道库有什么区别 - 堆栈溢出 (stackoverflow.com)</a></p><p>如果在具有企业托管证书的组织中使用 git，则需要使用安全通道。如果您仅使用 git 访问公共存储库（如 GitHub），或者您的组织不管理自己的证书，那么使用 SSL 后端（它们只是同一协议的不同实现）都可以。<br>从 <a href="https://github.com/git/git/commit/21084e84a418e0a6c4da72f632c5cd99386bd64b">https://github.com/git/git/commit/21084e84a418e0a6c4da72f632c5cd99386bd64b</a></p><pre><code>从版本 7.56.0 开始，curl 支持使用多个 SSL 后端进行编译。此修补程序添加了该功能的 Git 端：通过将 http.sslBackend 设置为“openssl”或“schannel”，Git for Windows 现在可以在运行时选择 SSL 后端。这在 Windows 上派上用场，因为安全通道（“schannel”）是访问 Windows 凭据存储的本机解决方案，从而允许企业范围的证书管理。由于历史原因，Git for Windows仍然需要支持OpenSSL，因为它以前是Git for Windows中唯一支持的SSL后端近十年了。该补丁已经在Git for Windows中进行了一年多，并且被认为是成熟的。</code></pre><h4 id="1-2-9-配置行尾符号转换"><a href="#1-2-9-配置行尾符号转换" class="headerlink" title="1.2.9 配置行尾符号转换"></a>1.2.9 配置行尾符号转换</h4><ul><li><p>Checkout Windows-style,commit Unix-style line endings</p><p>Git在检出文本文件时会将LF转换为CRLF。在提交文本文件时，会将CRLF转换为LT。对于跨平台的项目，这是Windows上的推荐设置(“core.autocrlf”设置为“true”)。</p></li><li><p>Checkout as-is,commit Unix-style line endings</p><p>当签出文本文件时，Git不会执行任何转换。提交文本文件时，CRLF将被转换为LF。对于跨平台项目，这是Unix上的推荐设置(“core.autocrlf”设置为“input”)。</p></li><li><p>Checkout as-is,commit as-is</p><p>当签出或提交文本文件时，Git不会执行任何转换。对于跨平台项目，不建议选择此选项(“core.autocrlf”设置为“false”)。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/line-ending.png"></p></li></ul><h4 id="1-2-10-配置终端模拟器以与-Git-Bash一起使用"><a href="#1-2-10-配置终端模拟器以与-Git-Bash一起使用" class="headerlink" title="1.2.10 配置终端模拟器以与 Git Bash一起使用"></a>1.2.10 配置终端模拟器以与 Git Bash一起使用</h4><ul><li><p>Use MinTTY (the default terminal of MSYS2)</p><p>Git Bash将使用MinTTY作为终端模拟器，它具有一个可调整大小的窗口非矩形选择和Unicode字体。Windows控制台程序(suc作为交互式Python)必须通过winpty启动才能在MinTTY工作。</p></li><li><p>Use Windows’default console window</p><p>Git将使用Windows的默认控制台窗口(“cmd.exe”)与Win32控制台程序，如交互式Python或node.js，但有一个非常有限的默认回滚，需要配置为使用Unicode字体以正确显示非ascii字符，并且在Windows 10之前为其窗口不能自由地调整大小，它只允许矩形文本选择。<br><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/terminalAndBash.png"></p></li></ul><h4 id="1-2-11-选择默认的”git-pull”行为-默认即可"><a href="#1-2-11-选择默认的”git-pull”行为-默认即可" class="headerlink" title="1.2.11 选择默认的”git pull”行为(默认即可)"></a>1.2.11 选择默认的”git pull”行为(默认即可)</h4><ul><li><p>Default (fast-forward or merge)</p><p>这是git pull的标准行为:在可能的情况下，将当前分支快进到获取的分支，否则创建一个merge commit。</p></li><li><p>Rebase</p><p>将当前分支重新基于获取的分支。如果没有对rebase的本地提交，这相当于快进。</p></li><li><p>Only ever fast-forward</p><p>快进到获取的分支。如果不可能，就失败。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/git_pull.png"></p></li></ul><h4 id="1-2-12-选择一个凭证助手"><a href="#1-2-12-选择一个凭证助手" class="headerlink" title="1.2.12 选择一个凭证助手"></a>1.2.12 选择一个凭证助手</h4><ul><li><p>Git Credential Manager</p><p>使用跨平台的Git Credential Manager。<br>在这里查看Git凭据管理器未来的更多信息。</p></li><li><p>None</p><p>不要使用凭据助手。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/credentialHelper.png"></p></li></ul><p>Git Credential Manager提供登录凭证帮助，Git 有时需要用户的凭据才能执行操作；例如，可能需要输入用户名和密码才能通过 HTTP 访问远程存储库。</p><h4 id="1-2-13-配置额外选项"><a href="#1-2-13-配置额外选项" class="headerlink" title="1.2.13 配置额外选项"></a>1.2.13 配置额外选项</h4><ul><li><p>Enable file system caching</p><p>对于某些操作，文件系统数据将被批量读取并缓存在内存中(“core.fscache”设置为“true”)。这提供了显著的性能提升。</p></li><li><p>Enable symbolic links</p><p>启用符号链接(需要SeCreateSymbolicLink权限)。 请注意，现有的存储库不受此设置的影响。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/extra_options.png"></p></li></ul><h4 id="1-2-14-配置实验性选项"><a href="#1-2-14-配置实验性选项" class="headerlink" title="1.2.14 配置实验性选项"></a>1.2.14 配置实验性选项</h4><ul><li><p>Enable experimental support for pseudo consoles.</p><p>这允许在Git Bash窗口中运行本机控制台程序，如Node或Python，而无需使用winpty，但它仍有已知的缺陷。</p></li><li><p>Enable experimental built-in file system monitor</p><p>自动运行内置的文件系统监视器，以加速包含许多文件的工作树中的常见操作，如git status ‘、git add ‘、git commit ‘等。</p><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/experimental_options.png"></p></li></ul><h3 id="二、idea安装git"><a href="#二、idea安装git" class="headerlink" title="二、idea安装git"></a>二、idea安装git</h3><h4 id="2-1-打开IDEA，选择File-settings-Version-Control-Git"><a href="#2-1-打开IDEA，选择File-settings-Version-Control-Git" class="headerlink" title="2.1 打开IDEA，选择File-settings-Version Control-Git"></a>2.1 打开IDEA，选择File-settings-Version Control-Git</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.1.png"></p><h4 id="2-2-Path-to-Git-executable右侧选择文件夹标志-Browse…-Shift-Enter-选择Git安装目录下bin-git-exe"><a href="#2-2-Path-to-Git-executable右侧选择文件夹标志-Browse…-Shift-Enter-选择Git安装目录下bin-git-exe" class="headerlink" title="2.2 Path to Git executable右侧选择文件夹标志(Browse…(Shift+Enter)),选择Git安装目录下bin-git.exe"></a>2.2 Path to Git executable右侧选择文件夹标志(Browse…(Shift+Enter)),选择Git安装目录下bin-git.exe</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.2.png"></p><h4 id="2-3-Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set-this-path-only-for-the-current-project下显示版本信息。"><a href="#2-3-Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set-this-path-only-for-the-current-project下显示版本信息。" class="headerlink" title="2.3 Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set this path only for the current project下显示版本信息。"></a>2.3 Test测试，点击旁边的Test按钮，由于idea版本不同，有些会弹窗显示git版本信息，有些会在Set this path only for the current project下显示版本信息。</h4><p><img src="/2022/05/23/Git%E5%88%9D%E4%BD%93%E9%AA%8C/2.3.png"></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/mukes/article/details/115693833">(25条消息) Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/23/hello-world/"/>
      <url>/2022/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
